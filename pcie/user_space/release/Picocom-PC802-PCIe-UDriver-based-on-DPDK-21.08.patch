diff -ruN -x '*.data' dpdk-21.08/app/meson.build npu_driver/pcie/user_space/DPDK/app/meson.build
--- dpdk-21.08/app/meson.build	2021-08-08 23:23:21.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/app/meson.build	2022-01-21 11:52:15.889570182 +0800
@@ -12,6 +12,7 @@
         'test-eventdev',
         'test-fib',
         'test-flow-perf',
+        'test-pc802',
         'test-pipeline',
         'test-pmd',
         'test-regex',
diff -ruN -x '*.data' dpdk-21.08/app/test-pc802/cmdline.c npu_driver/pcie/user_space/DPDK/app/test-pc802/cmdline.c
--- dpdk-21.08/app/test-pc802/cmdline.c	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/app/test-pc802/cmdline.c	2022-01-21 11:52:15.927570184 +0800
@@ -0,0 +1,736 @@
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <rte_debug.h>
+#include <cmdline_parse.h>
+#include <cmdline_parse_string.h>
+#include <cmdline_parse_num.h>
+#include <cmdline.h>
+
+#include <rte_pmd_pc802.h>
+
+extern int main_stop;
+
+struct cmd_quit_result {
+    cmdline_fixed_string_t quit;
+};
+
+static void cmd_quit_parsed(__attribute__((unused)) void *parsed_result,
+                struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    main_stop = 1;
+    cmdline_quit(cl);
+}
+
+cmdline_parse_token_string_t cmd_quit_quit =
+    TOKEN_STRING_INITIALIZER(struct cmd_quit_result, quit, "quit");
+
+cmdline_parse_inst_t cmd_quit = {
+    .f = cmd_quit_parsed,
+    .data = NULL,
+    .help_str = "quit: Exit application",
+    .tokens = {
+        (void *)&cmd_quit_quit,
+        NULL,
+    },
+};
+
+extern int test_case_No;
+
+struct cmd_run_test_case_result {
+    cmdline_fixed_string_t test;
+    cmdline_fixed_string_t caze;
+    int                    caseNo;
+};
+
+cmdline_parse_token_string_t cmd_run_test_case_result_test =
+    TOKEN_STRING_INITIALIZER(struct cmd_run_test_case_result, test, "test");
+cmdline_parse_token_string_t cmd_run_test_case_result_case =
+    TOKEN_STRING_INITIALIZER(struct cmd_run_test_case_result, caze, "case");
+cmdline_parse_token_num_t cmd_run_test_case_result_caseNo =
+    TOKEN_NUM_INITIALIZER(struct cmd_run_test_case_result, caseNo, RTE_INT32);
+
+static void cmd_run_test_case_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_run_test_case_result *res = parsed_result;
+    test_case_No = res->caseNo;
+}
+
+cmdline_parse_inst_t run_test_case = {
+    .f = cmd_run_test_case_parsed,
+    .data = NULL,
+    .help_str = "test case <case_number>",
+    .tokens = {
+        (void *)&cmd_run_test_case_result_test,
+        (void *)&cmd_run_test_case_result_case,
+        (void *)&cmd_run_test_case_result_caseNo,
+        NULL,
+        },
+};
+
+static void read_pc802_memory(uint32_t startAddr, uint32_t bytesNum)
+{
+    pc802_access_ep_mem(0, startAddr, bytesNum, DIR_PCIE_DMA_UPLINK);
+    uint8_t *p = (uint8_t *)pc802_get_debug_mem(0);
+    uint32_t k, r;
+    for (k = 0; k < bytesNum; k++) {
+        r = k & 0xF;
+        if (0 == r) {
+            printf("PC802-%08X : ", startAddr);
+            startAddr += 16;
+        }
+        printf("%02X ", *p++);
+        if (15 == r)
+            printf("\n");
+    }
+}
+
+#if 1
+static void read_npu_memory(uint64_t startAddr, uint32_t bytesNum)
+{
+    uint8_t *p = (uint8_t *)startAddr;
+    uint32_t k, r;
+    for (k = 0; k < bytesNum; k++) {
+        r = k & 0xF;
+        if (0 == r) {
+            printf("NPU-%016lX : ", startAddr);
+            startAddr += 16;
+        }
+        printf("%02X ", *p++);
+        if (15 == r)
+            printf("\n");
+    }
+}
+#endif
+
+struct cmd_read_memory_result {
+    cmdline_fixed_string_t read;
+    cmdline_fixed_string_t who;
+    uint64_t               startAddr;
+    uint32_t               bytesNum;
+};
+
+cmdline_parse_token_string_t cmd_read_memory_result_read =
+    TOKEN_STRING_INITIALIZER(struct cmd_read_memory_result, read, "read");
+cmdline_parse_token_string_t cmd_read_memory_result_who =
+    TOKEN_STRING_INITIALIZER(struct cmd_read_memory_result, who, "pc802#npu");
+cmdline_parse_token_num_t cmd_read_memory_result_startPhyAddr =
+    TOKEN_NUM_INITIALIZER(struct cmd_read_memory_result, startAddr, RTE_UINT64);
+cmdline_parse_token_num_t cmd_read_memory_result_bytesNum =
+    TOKEN_NUM_INITIALIZER(struct cmd_read_memory_result, bytesNum, RTE_UINT32);
+
+static void cmd_read_memory_result_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_read_memory_result *res = parsed_result;
+    uint64_t startAddr;
+    uint32_t bytesNum;
+    uint32_t offset;
+    offset = (uint32_t)(res->startAddr & 0xF);
+    startAddr = res->startAddr - offset;
+    bytesNum = res->bytesNum + offset;
+    bytesNum = (bytesNum + 15) & 0xFFFFFFF0;
+#if 1
+    if (!strcmp(res->who, "npu")) {
+        read_npu_memory(startAddr, bytesNum);
+    } else
+#endif
+    if (!strcmp(res->who, "pc802")) {
+        uint32_t pc802Addr = (uint32_t)startAddr;
+        read_pc802_memory(pc802Addr, bytesNum);
+    } else
+        return;
+
+    return;
+}
+
+cmdline_parse_inst_t read_memory = {
+    .f = cmd_read_memory_result_parsed,
+    .data = NULL,
+    .help_str = "read PC802 startPhyAddr bytesNum",
+    .tokens = {
+        (void *)&cmd_read_memory_result_read,
+        (void *)&cmd_read_memory_result_who,
+        (void *)&cmd_read_memory_result_startPhyAddr,
+        (void *)&cmd_read_memory_result_bytesNum,
+        NULL,
+        },
+};
+
+struct cmd_show_pcie_counter_result {
+    cmdline_fixed_string_t show;
+    cmdline_fixed_string_t pcie;
+    cmdline_fixed_string_t counter;
+};
+
+cmdline_parse_token_string_t cmd_show_pcie_counter_result_show =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pcie_counter_result, show, "show");
+cmdline_parse_token_string_t cmd_show_pcie_counter_result_pcie =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pcie_counter_result, pcie, "pcie");
+cmdline_parse_token_string_t cmd_show_pcie_counter_result_counter =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pcie_counter_result, counter, "counter");
+
+static void cmd_show_pcie_counter_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_show_pcie_counter_result *res = parsed_result;
+    RTE_ASSERT(!strcmp(res->show, "show"));
+    RTE_ASSERT(!strcmp(res->pcie, "pcie"));
+    RTE_ASSERT(!strcmp(res->counter, "counter"));
+    pc802_show_pcie_counter(0);
+}
+
+cmdline_parse_inst_t show_pcie_counter = {
+    .f = cmd_show_pcie_counter_parsed,
+    .data = NULL,
+    .help_str = "show PCIE counters of EP and RC",
+    .tokens = {
+        (void *)&cmd_show_pcie_counter_result_show,
+        (void *)&cmd_show_pcie_counter_result_pcie,
+        (void *)&cmd_show_pcie_counter_result_counter,
+        NULL,
+        },
+};
+
+struct cmd_show_pc802_info_result {
+    cmdline_fixed_string_t show;
+    cmdline_fixed_string_t dir;
+    cmdline_fixed_string_t type;
+    cmdline_fixed_string_t info;
+    uint16_t               idx;
+};
+
+cmdline_parse_token_string_t cmd_show_pc802_info_result_show =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_info_result, show, "show");
+cmdline_parse_token_string_t cmd_show_pc802_info_result_dir =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_info_result, dir, "dl#ul");
+cmdline_parse_token_string_t cmd_show_pc802_info_result_type =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_info_result, type, "data#ctrl");
+cmdline_parse_token_string_t cmd_show_pc802_info_result_info =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_info_result, info, "info");
+cmdline_parse_token_num_t cmd_show_pc802_info_result_idx =
+    TOKEN_NUM_INITIALIZER(struct cmd_show_pc802_info_result, idx, RTE_UINT16);
+
+static void cmd_show_pc802_info_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_show_pc802_info_result *res = parsed_result;
+    uint16_t dir;
+    if (!strcmp(res->dir, "dl")) {
+        dir = 0;
+    } else if (!strcmp(res->dir, "ul")) {
+        dir = 1;
+    } else {
+        printf("dir should be dl or ul\n");
+        return;
+    }
+
+    int queue_id;
+    if (!strcmp(res->type, "data")) {
+        queue_id = 1;
+    } else if (!strcmp(res->type, "ctrl")) {
+        queue_id = 2;
+    } else {
+        printf("type should be ctrl or data\n");
+        return;
+    }
+
+    if (dir) { // UL
+        pc802_show_rx_info(0, queue_id, res->idx);
+    } else { // DL
+        pc802_show_tx_info(0, queue_id, res->idx);
+    }
+}
+
+cmdline_parse_inst_t show_pc802_info = {
+    .f = cmd_show_pc802_info_parsed,
+    .data = NULL,
+    .help_str = "show PC802 Tx/Rx Desc, MBlk header, first 64 bytes of data",
+    .tokens = {
+        (void *)&cmd_show_pc802_info_result_show,
+        (void *)&cmd_show_pc802_info_result_dir,
+        (void *)&cmd_show_pc802_info_result_type,
+        (void *)&cmd_show_pc802_info_result_info,
+        (void *)&cmd_show_pc802_info_result_idx,
+        NULL,
+        },
+};
+
+struct cmd_show_pc802_data_result {
+    cmdline_fixed_string_t show;
+    cmdline_fixed_string_t dir;
+    cmdline_fixed_string_t type;
+    cmdline_fixed_string_t data;
+    uint16_t               idx;
+};
+
+cmdline_parse_token_string_t cmd_show_pc802_data_result_show =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_data_result, show, "show");
+cmdline_parse_token_string_t cmd_show_pc802_data_result_dir =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_data_result, dir, "dl#ul");
+cmdline_parse_token_string_t cmd_show_pc802_data_result_type =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_data_result, type, "data#ctrl");
+cmdline_parse_token_string_t cmd_show_pc802_data_result_data =
+    TOKEN_STRING_INITIALIZER(struct cmd_show_pc802_data_result, data, "data");
+cmdline_parse_token_num_t cmd_show_pc802_data_result_idx =
+    TOKEN_NUM_INITIALIZER(struct cmd_show_pc802_data_result, idx, RTE_UINT16);
+
+static void cmd_show_pc802_data_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_show_pc802_data_result *res = parsed_result;
+    uint16_t dir;
+    if (!strcmp(res->dir, "dl")) {
+        dir = 0;
+    } else if (!strcmp(res->dir, "ul")) {
+        dir = 1;
+    } else {
+        printf("dir should be dl or ul\n");
+        return;
+    }
+
+    int queue_id;
+    if (!strcmp(res->type, "data")) {
+        queue_id = 1;
+    } else if (!strcmp(res->type, "ctrl")) {
+        queue_id = 2;
+    } else {
+        printf("type should be ctrl or data\n");
+        return;
+    }
+
+    if (dir) { // UL
+        pc802_show_rx_data(0, queue_id, res->idx);
+    } else { // DL
+        pc802_show_tx_data(0, queue_id, res->idx);
+    }
+}
+
+cmdline_parse_inst_t show_pc802_data = {
+    .f = cmd_show_pc802_data_parsed,
+    .data = NULL,
+    .help_str = "show PC802 Tx/Rx Desc, MBlk header, all message data",
+    .tokens = {
+        (void *)&cmd_show_pc802_data_result_show,
+        (void *)&cmd_show_pc802_data_result_dir,
+        (void *)&cmd_show_pc802_data_result_type,
+        (void *)&cmd_show_pc802_data_result_data,
+        (void *)&cmd_show_pc802_data_result_idx,
+        NULL,
+        },
+};
+
+struct cmd_download_test_vector_result {
+    cmdline_fixed_string_t download;
+    uint32_t               pc802_mem;
+    uint32_t               byte_num;
+};
+
+cmdline_parse_token_string_t cmd_download_test_vector_result_download =
+    TOKEN_STRING_INITIALIZER(struct cmd_download_test_vector_result, download, "download");
+cmdline_parse_token_num_t cmd_download_test_vector_result_pc802_mem =
+    TOKEN_NUM_INITIALIZER(struct cmd_download_test_vector_result, pc802_mem, RTE_UINT32);
+cmdline_parse_token_num_t cmd_download_test_vector_result_byte_num =
+    TOKEN_NUM_INITIALIZER(struct cmd_download_test_vector_result, byte_num, RTE_UINT32);
+
+static void cmd_download_test_vector_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_download_test_vector_result *res = parsed_result;
+    FILE *fp = fopen("DL_test_vector.dat", "wb");
+    RTE_ASSERT(NULL != fp);
+    uint64_t *p0 = pc802_get_debug_mem(0);
+    uint32_t k;
+
+    uint32_t *p = (uint32_t *)p0;
+    for (k = 0; k < res->byte_num; k += sizeof(uint32_t))
+        *p++ = rand();
+
+    uint64_t s, ns;
+    struct timespec t_start, t_end;
+    clock_gettime(CLOCK_MONOTONIC_RAW, &t_start);
+
+    pc802_access_ep_mem(0, res->pc802_mem, res->byte_num, DIR_PCIE_DMA_DOWNLINK);
+
+    clock_gettime(CLOCK_MONOTONIC_RAW, &t_end);
+    ns = ((t_end.tv_sec - t_start.tv_sec) * 1E9);
+    ns += (t_end.tv_nsec - t_start.tv_nsec);
+    s = (t_end.tv_sec - t_start.tv_sec);
+
+    printf("Download Test Vector: NPU --->>> PC802\n");
+    printf("\tbyte_num = %9u  took  %lu (0x%lX) ns\n", res->byte_num, ns, ns);
+    printf("\t\t about %lu second \n", s);
+
+    fwrite(p0, 1, res->byte_num, fp);
+    fclose(fp);
+}
+
+cmdline_parse_inst_t download_test_vector = {
+    .f = cmd_download_test_vector_parsed,
+    .data = NULL,
+    .help_str = "Test time used to download test vector",
+    .tokens = {
+        (void *)&cmd_download_test_vector_result_download,
+        (void *)&cmd_download_test_vector_result_pc802_mem,
+        (void *)&cmd_download_test_vector_result_byte_num,
+        NULL,
+        },
+};
+
+static unsigned long get_file_size(const char *filename)
+{
+    unsigned long size;
+    FILE* fp = fopen( filename, "rb" );
+    if(fp==NULL)
+    {
+        printf("ERROR: Open file %s failed.\n", filename);
+        return 0;
+    }
+    fseek( fp, SEEK_SET, SEEK_END );
+    size=ftell(fp);
+    fclose(fp);
+    return size;
+}
+
+static void check_down_up(void)
+{
+    unsigned long sz1, sz2;
+    sz1 = get_file_size("DL_test_vector.dat");
+    sz2 = get_file_size("UL_test_vector.dat");
+    if (sz1 != sz2) {
+        printf("Download and UPload File Size Not Equal !!!\n");
+        return;
+    }
+    uint8_t d1, d2;
+    unsigned long k;
+    FILE *fp1, *fp2;
+    RTE_ASSERT(NULL != (fp1 = fopen("DL_test_vector.dat", "rb")));
+    RTE_ASSERT(NULL != (fp2 = fopen("UL_test_vector.dat", "rb")));
+    int flag = 1;
+    for (k = 0; flag && (k < sz1); k++) {
+        RTE_ASSERT(1 == fread(&d1, 1, 1, fp1));
+        RTE_ASSERT(1 == fread(&d2, 1, 1, fp2));
+        flag = (d1 == d2);
+    }
+    fclose(fp1);
+    fclose(fp2);
+    if (flag) {
+        printf("Download File == Upload File !\n");
+    } else {
+        printf("Download File != Upload File at k = %lu!\n", k);
+    }
+}
+
+struct cmd_upload_test_vector_result {
+    cmdline_fixed_string_t upload;
+    uint32_t               pc802_mem;
+    uint32_t               byte_num;
+};
+
+cmdline_parse_token_string_t cmd_upload_test_vector_result_download =
+    TOKEN_STRING_INITIALIZER(struct cmd_upload_test_vector_result, upload, "upload");
+cmdline_parse_token_num_t cmd_upload_test_vector_result_pc802_mem =
+    TOKEN_NUM_INITIALIZER(struct cmd_upload_test_vector_result, pc802_mem, RTE_UINT32);
+cmdline_parse_token_num_t cmd_upload_test_vector_result_byte_num =
+    TOKEN_NUM_INITIALIZER(struct cmd_upload_test_vector_result, byte_num, RTE_UINT32);
+
+static void cmd_upload_test_vector_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_upload_test_vector_result *res = parsed_result;
+    FILE *fp = fopen("UL_test_vector.dat", "wb");
+    RTE_ASSERT(NULL != fp);
+    uint64_t *p0 = pc802_get_debug_mem(0);
+    memset(p0, 0, res->byte_num);
+
+    uint64_t s, ns;
+    struct timespec t_start, t_end;
+    clock_gettime(CLOCK_MONOTONIC_RAW, &t_start);
+
+    pc802_access_ep_mem(0, res->pc802_mem, res->byte_num, DIR_PCIE_DMA_UPLINK);
+
+    clock_gettime(CLOCK_MONOTONIC_RAW, &t_end);
+    ns = ((t_end.tv_sec - t_start.tv_sec) * 1E9);
+    ns += (t_end.tv_nsec - t_start.tv_nsec);
+    s = (t_end.tv_sec - t_start.tv_sec);
+
+    printf("Upload Test Vector: NPU <<<--- PC802\n");
+    printf("\tbyte_num = %9u  took  %lu (0x%lX) ns\n", res->byte_num, ns, ns);
+    printf("\t\t about %lu second \n", s);
+
+    fwrite(p0, 1, res->byte_num, fp);
+    fclose(fp);
+
+    check_down_up();
+}
+
+cmdline_parse_inst_t upload_test_vector = {
+    .f = cmd_upload_test_vector_parsed,
+    .data = NULL,
+    .help_str = "Test time used to download test vector",
+    .tokens = {
+        (void *)&cmd_upload_test_vector_result_download,
+        (void *)&cmd_upload_test_vector_result_pc802_mem,
+        (void *)&cmd_upload_test_vector_result_byte_num,
+        NULL,
+        },
+};
+
+struct cmd_test_memdump_result {
+    cmdline_fixed_string_t test;
+    cmdline_fixed_string_t memdump;
+    uint32_t               pc802_mem;
+    uint32_t               byte_num;
+};
+
+cmdline_parse_token_string_t cmd_test_memdump_result_test =
+    TOKEN_STRING_INITIALIZER(struct cmd_test_memdump_result, test, "test");
+cmdline_parse_token_string_t cmd_test_memdump_result_memdump =
+    TOKEN_STRING_INITIALIZER(struct cmd_test_memdump_result, memdump, "memdump");
+cmdline_parse_token_num_t cmd_test_memdump_result_pc802_mem =
+    TOKEN_NUM_INITIALIZER(struct cmd_test_memdump_result, pc802_mem, RTE_UINT32);
+cmdline_parse_token_num_t cmd_test_memdump_result_byte_num =
+    TOKEN_NUM_INITIALIZER(struct cmd_test_memdump_result, byte_num, RTE_UINT32);
+
+void test_pc802_mem_dump(uint32_t          pc802_mem, uint32_t byte_num);
+
+static void cmd_test_memdump_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_test_memdump_result *res = parsed_result;
+    test_pc802_mem_dump(res->pc802_mem, res->byte_num);
+}
+
+cmdline_parse_inst_t test_memdump = {
+    .f = cmd_test_memdump_parsed,
+    .data = NULL,
+    .help_str = "Test memdump from PC802",
+    .tokens = {
+        (void *)&cmd_test_memdump_result_test,
+        (void *)&cmd_test_memdump_result_memdump,
+        (void *)&cmd_test_memdump_result_pc802_mem,
+        (void *)&cmd_test_memdump_result_byte_num,
+        NULL,
+        },
+};
+
+struct cmd_set_test_data_mode_result {
+    cmdline_fixed_string_t set;
+    cmdline_fixed_string_t data;
+    int                    mode;
+};
+
+cmdline_parse_token_string_t cmd_set_test_data_mode_result_set =
+    TOKEN_STRING_INITIALIZER(struct cmd_set_test_data_mode_result, set, "set");
+cmdline_parse_token_string_t cmd_set_test_data_mode_result_data =
+    TOKEN_STRING_INITIALIZER(struct cmd_set_test_data_mode_result, data, "data");
+cmdline_parse_token_num_t cmd_set_test_data_mode_result_mode =
+    TOKEN_NUM_INITIALIZER(struct cmd_set_test_data_mode_result, mode, RTE_INT32);
+
+extern int testpc802_data_mode;
+static void cmd_set_test_data_mode_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_set_test_data_mode_result *res = parsed_result;
+    printf("PC802 Test Data Mode : %d -->> %d\n", testpc802_data_mode, res->mode);
+    testpc802_data_mode = res->mode;
+}
+
+cmdline_parse_inst_t set_test_data_mode = {
+    .f = cmd_set_test_data_mode_parsed,
+    .data = NULL,
+    .help_str = "set data <mode>",
+    .tokens = {
+        (void *)&cmd_set_test_data_mode_result_set,
+        (void *)&cmd_set_test_data_mode_result_data,
+        (void *)&cmd_set_test_data_mode_result_mode,
+        NULL,
+        },
+};
+
+struct cmd_exit_test_loop_result {
+    cmdline_fixed_string_t exit;
+    cmdline_fixed_string_t loop;
+};
+
+cmdline_parse_token_string_t cmd_exit_test_loop_result_exit =
+    TOKEN_STRING_INITIALIZER(struct cmd_exit_test_loop_result, exit, "exit");
+cmdline_parse_token_string_t cmd_exit_test_loop_result_loop =
+    TOKEN_STRING_INITIALIZER(struct cmd_exit_test_loop_result, loop, "loop");
+
+extern int testpc802_exit_loop;
+static void cmd_exit_test_loop_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_exit_test_loop_result *res = parsed_result;
+    res = res;
+    testpc802_exit_loop = 1;
+}
+
+cmdline_parse_inst_t exit_test_loop = {
+    .f = cmd_exit_test_loop_parsed,
+    .data = NULL,
+    .help_str = "exit loop",
+    .tokens = {
+        (void *)&cmd_exit_test_loop_result_exit,
+        (void *)&cmd_exit_test_loop_result_loop,
+        NULL,
+        },
+};
+
+struct cmd_set_ul_dma_count_result {
+    cmdline_fixed_string_t set;
+    cmdline_fixed_string_t ul;
+    cmdline_fixed_string_t dma;
+    uint32_t               cnt;
+};
+
+cmdline_parse_token_string_t cmd_set_ul_dma_count_result_set =
+    TOKEN_STRING_INITIALIZER(struct cmd_set_ul_dma_count_result, set, "set");
+cmdline_parse_token_string_t cmd_set_ul_dma_count_result_ul =
+    TOKEN_STRING_INITIALIZER(struct cmd_set_ul_dma_count_result, ul, "ul");
+cmdline_parse_token_string_t cmd_set_ul_dma_count_result_dma =
+    TOKEN_STRING_INITIALIZER(struct cmd_set_ul_dma_count_result, dma, "dma");
+cmdline_parse_token_num_t cmd_set_ul_dma_count_result_cnt =
+    TOKEN_NUM_INITIALIZER(struct cmd_set_ul_dma_count_result, cnt, RTE_UINT32);
+
+static void cmd_set_ul_dma_count_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_set_ul_dma_count_result *res = parsed_result;
+    pc802_set_ul_dma_count(0, res->cnt);
+}
+
+cmdline_parse_inst_t set_ul_dma_count = {
+    .f = cmd_set_ul_dma_count_parsed,
+    .data = NULL,
+    .help_str = "set ul dma <counter>",
+    .tokens = {
+        (void *)&cmd_set_ul_dma_count_result_set,
+        (void *)&cmd_set_ul_dma_count_result_ul,
+        (void *)&cmd_set_ul_dma_count_result_dma,
+        (void *)&cmd_set_ul_dma_count_result_cnt,
+        NULL,
+        },
+};
+
+struct cmd_vec_read_result {
+    cmdline_fixed_string_t vec;
+    cmdline_fixed_string_t read;
+    uint32_t               file_id;
+    uint32_t               offset;
+    uint32_t               pc802_address;
+    uint32_t               length;
+};
+
+cmdline_parse_token_string_t cmd_vec_read_result_vec =
+    TOKEN_STRING_INITIALIZER(struct cmd_vec_read_result, vec, "vec");
+cmdline_parse_token_string_t cmd_vec_read_result_read =
+    TOKEN_STRING_INITIALIZER(struct cmd_vec_read_result, read, "read");
+cmdline_parse_token_num_t cmd_vec_read_result_file_id =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_read_result, file_id, RTE_UINT32);
+cmdline_parse_token_num_t cmd_vec_read_result_offset =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_read_result, offset, RTE_UINT32);
+cmdline_parse_token_num_t cmd_vec_read_result_pc802_address =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_read_result, pc802_address, RTE_UINT32);
+cmdline_parse_token_num_t cmd_vec_read_result_length =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_read_result, length, RTE_UINT32);
+
+static void cmd_vec_read_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_vec_read_result *res = parsed_result;
+    pc802_vec_read(res->file_id, res->offset, res->pc802_address, res->length);
+}
+
+cmdline_parse_inst_t vec_read = {
+    .f = cmd_vec_read_parsed,
+    .data = NULL,
+    .help_str = "vec read <file_id> <offset> <pc802_address> <length>",
+    .tokens = {
+        (void *)&cmd_vec_read_result_vec,
+        (void *)&cmd_vec_read_result_read,
+        (void *)&cmd_vec_read_result_file_id,
+        (void *)&cmd_vec_read_result_offset,
+        (void *)&cmd_vec_read_result_pc802_address,
+        (void *)&cmd_vec_read_result_length,
+        NULL,
+        },
+};
+
+struct cmd_vec_dump_result {
+    cmdline_fixed_string_t vec;
+    cmdline_fixed_string_t dump;
+    uint32_t               file_id;
+    uint32_t               pc802_address;
+    uint32_t               length;
+};
+
+cmdline_parse_token_string_t cmd_vec_dump_result_vec =
+    TOKEN_STRING_INITIALIZER(struct cmd_vec_dump_result, vec, "vec");
+cmdline_parse_token_string_t cmd_vec_dump_result_dump =
+    TOKEN_STRING_INITIALIZER(struct cmd_vec_dump_result, dump, "dump");
+cmdline_parse_token_num_t cmd_vec_dump_result_file_id =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_dump_result, file_id, RTE_UINT32);
+cmdline_parse_token_num_t cmd_vec_dump_result_pc802_address =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_dump_result, pc802_address, RTE_UINT32);
+cmdline_parse_token_num_t cmd_vec_dump_result_length =
+    TOKEN_NUM_INITIALIZER(struct cmd_vec_dump_result, length, RTE_UINT32);
+
+static void cmd_vec_dump_parsed(void *parsed_result,
+                __attribute__((unused)) struct cmdline *cl,
+                __attribute__((unused)) void *data)
+{
+    struct cmd_vec_dump_result *res = parsed_result;
+    pc802_vec_dump(res->file_id, res->pc802_address, res->length);
+}
+
+cmdline_parse_inst_t vec_dump = {
+    .f = cmd_vec_dump_parsed,
+    .data = NULL,
+    .help_str = "vec dump <file_id> <pc802_address> <length>",
+    .tokens = {
+        (void *)&cmd_vec_dump_result_vec,
+        (void *)&cmd_vec_dump_result_dump,
+        (void *)&cmd_vec_dump_result_file_id,
+        (void *)&cmd_vec_dump_result_pc802_address,
+        (void *)&cmd_vec_dump_result_length,
+        NULL,
+        },
+};
+
+cmdline_parse_ctx_t main_ctx[] = {
+    (cmdline_parse_inst_t *)&cmd_quit,
+    (cmdline_parse_inst_t *)&run_test_case,
+    (cmdline_parse_inst_t *)&read_memory,
+    (cmdline_parse_inst_t *)&show_pcie_counter,
+    (cmdline_parse_inst_t *)&show_pc802_info,
+    (cmdline_parse_inst_t *)&show_pc802_data,
+    (cmdline_parse_inst_t *)&download_test_vector,
+    (cmdline_parse_inst_t *)&upload_test_vector,
+    (cmdline_parse_inst_t *)&test_memdump,
+    (cmdline_parse_inst_t *)&set_test_data_mode,
+    (cmdline_parse_inst_t *)&exit_test_loop,
+    (cmdline_parse_inst_t *)&set_ul_dma_count,
+    (cmdline_parse_inst_t *)&vec_read,
+    (cmdline_parse_inst_t *)&vec_dump,
+    NULL,
+};
+
diff -ruN -x '*.data' dpdk-21.08/app/test-pc802/meson.build npu_driver/pcie/user_space/DPDK/app/test-pc802/meson.build
--- dpdk-21.08/app/test-pc802/meson.build	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/app/test-pc802/meson.build	2022-01-21 11:52:15.927570184 +0800
@@ -0,0 +1,16 @@
+# Copyright(c) 2020 PICOCOM Corporation
+
+# override default name to drop the hyphen
+name = 'testpc802'
+cflags += '-Wno-deprecated-declarations'
+cflags += '-DRTE_ENABLE_ASSERT'
+sources = files(
+        'cmdline.c',
+        'testpc802.c',
+)
+
+deps += ['ethdev', 'cmdline', 'bus_pci']
+
+if dpdk_conf.has('RTE_NET_PC802')
+    deps += 'net_pc802'
+endif
diff -ruN -x '*.data' dpdk-21.08/app/test-pc802/testpc802.c npu_driver/pcie/user_space/DPDK/app/test-pc802/testpc802.c
--- dpdk-21.08/app/test-pc802/testpc802.c	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/app/test-pc802/testpc802.c	2022-01-21 11:52:15.927570184 +0800
@@ -0,0 +1,1393 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018-2020 Picocom Corporation
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <string.h>
+#include <time.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <stdbool.h>
+
+#include <sys/queue.h>
+#include <sys/stat.h>
+
+#include <stdint.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include <rte_common.h>
+#include <rte_errno.h>
+#include <rte_byteorder.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_cycles.h>
+#include <rte_memory.h>
+#include <rte_memcpy.h>
+#include <rte_launch.h>
+#include <rte_eal.h>
+#include <rte_alarm.h>
+#include <rte_per_lcore.h>
+#include <rte_lcore.h>
+#include <rte_atomic.h>
+#include <rte_branch_prediction.h>
+#include <rte_mempool.h>
+#include <rte_malloc.h>
+#include <rte_mbuf.h>
+#include <rte_mbuf_pool_ops.h>
+#include <rte_interrupts.h>
+#include <rte_pci.h>
+#include <rte_ether.h>
+#include <rte_ethdev.h>
+#include <rte_dev.h>
+#include <rte_string_fns.h>
+
+#include <cmdline_rdline.h>
+#include <cmdline_parse.h>
+#include <cmdline_socket.h>
+#include <cmdline.h>
+
+#include <rte_pmd_pc802.h>
+#include <pcxx_ipc.h>
+
+#define TEST_PC802_DISP_LOOP_NUM    10000
+
+int testpc802_data_mode = 0;
+int testpc802_exit_loop = 0;
+
+struct rte_mempool *mpool_pc802_tx;
+
+#define MAX_DATA_BUF_SZ (256*1024)
+
+typedef union {
+    uint32_t _d[MAX_DATA_BUF_SZ / sizeof(uint32_t)];
+    struct {
+        uint32_t s;
+        uint32_t N;
+        uint32_t d[0];
+    };
+} DataBuf_t;
+
+static void
+signal_handler(int signum)
+{
+    if (signum == SIGINT || signum == SIGTERM) {
+        printf("\n\nSignal %d received, preparing to exit...\n",
+                signum);
+        //force_quit = true;
+        signal(signum, SIG_DFL);
+        kill(getpid(), signum);
+    }
+}
+
+static const struct rte_eth_conf dev_conf = {
+        .rxmode = {
+            .max_rx_pkt_len = RTE_ETHER_MAX_LEN,
+        },
+    };
+
+static uint32_t process_ul_ctrl_msg(const char* buf, uint32_t payloadSize);
+static uint32_t process_dl_ctrl_msg(const char* buf, uint32_t payloadSize);
+static uint32_t process_ul_oam_msg(const char* buf, uint32_t payloadSize);
+static uint32_t process_dl_oam_msg(const char* buf, uint32_t payloadSize);
+static uint32_t process_ul_data_msg(const char* buf, uint32_t payloadSize);
+static uint32_t process_dl_data_msg(const char* buf, uint32_t payloadSize);
+
+static pcxxInfo_s   ctrl_cb_info = {process_ul_ctrl_msg, process_dl_ctrl_msg};
+static pcxxInfo_s   oam_cb_info  = {process_ul_oam_msg,  process_dl_oam_msg };
+static pcxxInfo_s   data_cb_info = {process_ul_data_msg, process_dl_data_msg};
+
+static int port_init(uint16_t port)
+{
+    struct rte_mempool *mbuf_pool;
+    //const struct rte_eth_conf dev_conf;
+    struct rte_eth_dev_info dev_info;
+    struct rte_eth_txconf tx_conf;
+    //const struct rte_eth_rxconf rx_conf;
+    int socket_id;
+
+    rte_eth_dev_info_get(port, &dev_info);
+    socket_id = dev_info.device->numa_node;
+
+    mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL_ETH_TX", 2048,
+            128, 0, RTE_MBUF_DEFAULT_BUF_SIZE, socket_id);
+    if (mbuf_pool == NULL)
+        rte_exit(EXIT_FAILURE, "Cannot create mbuf pool on Line %d\n", __LINE__);
+    mpool_pc802_tx = mbuf_pool;
+
+    mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL_ETH_RX", 2048,
+            128 , 0, RTE_MBUF_DEFAULT_BUF_SIZE, socket_id);
+    if (mbuf_pool == NULL)
+        rte_exit(EXIT_FAILURE, "Cannot create mbuf pool on Line %d\n", __LINE__);
+
+    rte_eth_dev_configure(port, 1, 1, &dev_conf);
+    tx_conf = dev_info.default_txconf;
+    rte_eth_tx_queue_setup(port, 0, 128, socket_id, &tx_conf);
+    rte_eth_rx_queue_setup(port, 0, 128, socket_id, NULL, mbuf_pool);
+
+    pcxxDataOpen(&data_cb_info);
+
+    pcxxCtrlOpen(&ctrl_cb_info);
+
+    pcxxOamOpen(&oam_cb_info);
+
+    rte_eth_dev_start(port);
+
+    printf("Finished port_init !\n");
+
+    return 0;
+}
+
+
+static uint32_t * alloc_tx_blk(uint16_t qId)
+{
+    PC802_Mem_Block_t *mblk;
+    mblk = pc802_alloc_tx_mem_block(0, qId);
+    if (mblk)
+        return (uint32_t *)&mblk[1];
+    return NULL;
+}
+
+static void free_blk(uint32_t *blk)
+{
+    char *p = (char *)blk;
+    if (p) {
+        p -= sizeof(PC802_Mem_Block_t);
+        pc802_free_mem_block((PC802_Mem_Block_t *)p);
+    }
+}
+
+static uint16_t tx_blks(uint16_t qId, uint32_t **blks, uint16_t nb_blks)
+{
+    uint16_t k;
+    PC802_Mem_Block_t *tx_blks[32];
+    RTE_ASSERT(nb_blks <= 32);
+    for (k = 0; k <nb_blks; k++)
+        tx_blks[k] = (PC802_Mem_Block_t *)((char *)blks[k] - sizeof(PC802_Mem_Block_t));
+    return pc802_tx_mblk_burst(0, qId, tx_blks, nb_blks);
+}
+
+static uint16_t rx_blks(uint16_t qId, uint32_t **blks, uint16_t nb_blks)
+{
+    uint16_t k;
+    nb_blks = pc802_rx_mblk_burst(0, qId, (PC802_Mem_Block_t **)blks, nb_blks);
+    for (k = 0; k < nb_blks; k++) {
+        blks[k] += (sizeof(PC802_Mem_Block_t) / sizeof(uint32_t));
+    }
+    return nb_blks;
+}
+
+static void set_blk_attr(uint32_t *blk, uint32_t length, uint8_t type, uint8_t eop)
+{
+    PC802_Mem_Block_t *mblk;
+    if (blk) {
+        mblk = (PC802_Mem_Block_t *)((char *)blk - sizeof(PC802_Mem_Block_t));
+        mblk->pkt_length = length;
+        mblk->pkt_type = type;
+        mblk->eop = eop;
+    }
+}
+
+static void get_blk_attr(uint32_t *blk, uint32_t *length, uint8_t *type, uint8_t *eop)
+{
+    PC802_Mem_Block_t *mblk;
+    if (blk) {
+        mblk = (PC802_Mem_Block_t *)((char *)blk - sizeof(PC802_Mem_Block_t));
+        *length = mblk->pkt_length;
+        *type = mblk->pkt_type;
+        *eop = mblk->eop;
+    }
+}
+
+static int produce_random_dl_src_data(uint32_t *buf)
+{
+    //static uint32_t idx = 0;
+    uint32_t N, s, d, k;
+    do {
+        s = (uint32_t)rand();
+    } while (s == 0x4b3c2d1e);
+    *buf++ = s;
+    N = (uint32_t)rand();
+    N &= 511;
+    if (N < 10) N = 10;
+    if (N > 500) N = 500;
+    *buf++ = N;
+    d = (uint32_t)rand();
+    //printf("DL_MSG[1][%3u]: N=%3u S=0x%08X D=0x%08X\n", idx++, N, s, d);
+    for (k = 0; k < N; k++) {
+        *buf++ = d;
+        d += s;
+    }
+    return 0;
+}
+
+static int produce_fixed_dl_src_data_1(uint32_t *buf, uint16_t qId)
+{
+    //static uint32_t idx = 0;
+    uint32_t N, s, d, k;
+    s = 0;
+    *buf++ = s;
+    N = 500;
+    *buf++ = N;
+    d = 0x11111111 * (1 + qId);
+    //printf("DL_MSG[1][%3u]: N=%3u S=0x%08X D=0x%08X\n", idx++, N, s, d);
+    for (k = 0; k < N; k++) {
+        *buf++ = d;
+        d += s;
+    }
+    return 0;
+}
+
+static int produce_fixed_dl_src_data_2(uint32_t *buf, uint16_t qId)
+{
+    //static uint32_t idx = 0;
+    static uint32_t d0[8] = {1, 2, 3, 4, 5, 6, 7, 8};
+    uint32_t N, s, d, k;
+    s = 1;
+    *buf++ = s;
+    N = 500;
+    *buf++ = N;
+    d = d0[qId];
+    d0[qId]++;
+    //printf("DL_MSG[1][%3u]: N=%3u S=0x%08X D=0x%08X\n", idx++, N, s, d);
+    for (k = 0; k < N; k++) {
+        *buf++ = d;
+        d += s;
+    }
+    return 0;
+}
+
+static int produce_fixed_dl_src_data_3(uint32_t *buf, uint16_t qId)
+{
+    static uint32_t d0[8] = {1, 2, 3, 4, 5, 6, 7, 8};
+    static uint32_t L = 400;
+    uint32_t N, s, d, k;
+    s = 1;
+    *buf++ = s;
+    if (L >= 501) L = 400;
+    N = L++;
+    *buf++ = N;
+    d = d0[qId];
+    d0[qId]++;
+    for (k = 0; k < N; k++) {
+        *buf++ = d;
+        d += s;
+    }
+    return 0;
+}
+
+static int produce_dl_src_data(uint32_t *buf, uint16_t qId)
+{
+    if (0 == testpc802_data_mode) {
+        produce_random_dl_src_data(buf);
+    } else if (1 == testpc802_data_mode) {
+        produce_fixed_dl_src_data_1(buf, qId);
+    } else if (2 == testpc802_data_mode) {
+        produce_fixed_dl_src_data_2(buf, qId);
+    } else {
+        produce_fixed_dl_src_data_3(buf, qId);
+    }
+    return 0;
+}
+
+static int check_single_same(uint32_t *a, uint32_t *b)
+{
+    uint32_t k, N;
+    uint32_t err_cnt;
+    int res;
+    err_cnt = 0;
+    res = 0;
+    N = a[1] + 2;
+    for (k = 0; k < N; k++) {
+        if (a[k] != b[k]) {
+            res = -1;
+            DBLOG("ERROR: a[%3u] = 0x%08X  !=  b[%3u] = 0x%08X\n",
+                k, a[k], k, b[k]);
+            err_cnt++;
+            if (16 == err_cnt)
+                return -1;
+        }
+   }
+   return res;
+}
+
+static int check_same(uint32_t **a, uint16_t na, uint32_t *b)
+{
+    uint32_t *pa;
+    uint32_t N;
+    uint16_t k;
+    for (k = 0; k < na; k++) {
+        pa = a[k];
+        N = pa[1] + 2;
+        if (check_single_same(pa, b)) {
+            DBLOG("ERROR: k = %hu\n", k);
+            return -1;
+        }
+        b += N;
+    }
+    return 0;
+}
+
+static void swap_msg(uint32_t *a, uint32_t msgSz)
+{
+    uint32_t d;
+    while (msgSz) {
+        d = *a;
+        *a++ = ~d;
+        msgSz -= sizeof(uint32_t);
+    }
+    return;
+}
+
+#define QID_DATA    PC802_TRAFFIC_5G_EMBB_DATA
+#define QID_CTRL    PC802_TRAFFIC_5G_EMBB_CTRL
+#define QID_OAM     PC802_TRAFFIC_OAM
+
+static union {
+    const char *cc;
+    uint32_t   *up;
+} dl_a[17];
+static uint32_t dl_a_num = 0;
+static union {
+    const char *cc;
+    uint32_t   *up;
+} dl_oam[32];
+static uint32_t dl_oam_num = 0;
+
+static int      atl_test_result;
+
+static uint32_t process_dl_ctrl_msg(const char* buf, uint32_t payloadSize)
+{
+    payloadSize = payloadSize;
+    dl_a[dl_a_num].cc = buf;
+    dl_a_num++;
+    return 0;
+}
+
+static uint32_t process_ul_ctrl_msg(const char* buf, uint32_t payloadSize)
+{
+    uint64_t addr = (uint64_t)buf;
+    uint32_t *ul_msg = (uint32_t *)addr;
+    swap_msg(ul_msg, payloadSize);
+    uint32_t *dl_msg;
+    dl_msg = dl_a[dl_a_num - 1].up;
+    if (check_same(&dl_msg, 1, ul_msg)) {
+        atl_test_result |= 1;
+    }
+    dl_a_num = 0;
+    return payloadSize;
+}
+
+static uint32_t process_dl_oam_msg(const char* buf, uint32_t payloadSize)
+{
+    buf = buf;
+    payloadSize = payloadSize;
+    dl_oam[dl_oam_num].cc = buf;
+    dl_oam_num++;
+    return 0;
+}
+
+static uint32_t process_ul_oam_msg(const char* buf, uint32_t payloadSize)
+{
+    uint64_t addr = (uint64_t)buf;
+    uint32_t *ul_msg = (uint32_t *)addr;
+    swap_msg(ul_msg, payloadSize);
+    uint32_t **dl_msg;
+    dl_msg = &dl_oam[0].up;
+    if (check_same(dl_msg, dl_oam_num, ul_msg)) {
+        atl_test_result |= 4;
+    }
+    dl_oam_num = 0;
+    return payloadSize;
+}
+
+static uint32_t process_dl_data_msg(const char* buf, uint32_t payloadSize)
+{
+    payloadSize = payloadSize;
+    dl_a[dl_a_num].cc = buf;
+    dl_a_num++;
+    return 0;
+}
+
+static uint32_t process_ul_data_msg(const char* buf, uint32_t payloadSize)
+{
+    uint64_t addr = (uint64_t)buf;
+    uint32_t *ul_msg = (uint32_t *)addr;
+    swap_msg(ul_msg, payloadSize);
+    uint32_t **dl_msg;
+    dl_msg = &dl_a[0].up;
+    if (check_same(dl_msg, dl_a_num - 1, ul_msg)) {
+        atl_test_result |= 2;
+    }
+    return payloadSize;
+}
+
+static int case1(void)
+{
+    int re;
+    uint32_t N;
+    uint32_t *a = alloc_tx_blk(QID_CTRL);
+    if (NULL == a) return -1;
+
+    produce_dl_src_data(a, QID_CTRL);
+    N = sizeof(uint32_t) * (a[1] + 2);
+    set_blk_attr(a, N, 2, 1);
+    tx_blks(QID_CTRL, &a, 1);
+
+    uint32_t *b;
+    while (0 == rx_blks(QID_CTRL, &b, 1));
+    uint32_t length = 0;
+    uint8_t type, eop = 0;
+    get_blk_attr(b, &length, &type, &eop);
+    if ((type != 2) || (eop != 1))
+        return -1;
+    swap_msg(b, length);
+    //printf("CASE1: UL msg length = %u\n", length);
+    //check_ul_dst_data(b, length);
+    re = check_single_same(a, b);
+    free_blk(a);
+    free_blk(b);
+    return re;
+}
+
+static int case101(void)
+{
+    char *a;
+    uint32_t *A;
+    uint32_t N;
+    uint32_t avail;
+
+    pcxxSendStart();
+    RTE_ASSERT(0 == pcxxCtrlAlloc(&a, &avail));
+    A = (uint32_t *)a;
+    produce_dl_src_data(A, QID_CTRL);
+    N = sizeof(uint32_t) * (A[1] + 2);
+    pcxxCtrlSend(a, N);
+    pcxxSendEnd();
+
+    while (-1 == pcxxCtrlRecv());
+    int re = atl_test_result;
+    atl_test_result = 0;
+    return re;
+}
+
+static int case2(void)
+{
+    uint32_t N;
+    uint32_t *a[2];
+    uint32_t *b[2];
+    uint32_t length = 0;
+    uint8_t type, eop;
+
+    a[0] = alloc_tx_blk(QID_DATA);
+    produce_dl_src_data(a[0], QID_DATA);
+    N = sizeof(uint32_t) * (a[0][1] + 2);
+    set_blk_attr(a[0], N, 0, 1);
+    tx_blks(QID_DATA, &a[0], 1);
+
+    a[1] = alloc_tx_blk(QID_CTRL);
+    produce_dl_src_data(a[1], QID_CTRL);
+    N = sizeof(uint32_t) * (a[1][1] + 2);
+    set_blk_attr(a[1], N, 1, 1);
+    tx_blks(QID_CTRL, &a[1], 1);
+
+    uint16_t s;
+    do {
+        s = rx_blks(QID_DATA, &b[0], 1);
+    } while(0 == s);
+    do {
+        s = rx_blks(QID_CTRL, &b[1], 1);
+    } while(0 == s);
+
+    get_blk_attr(b[0], &length, &type, &eop);
+    swap_msg(b[0], length);
+    if (check_single_same(a[0], b[0]))
+        return -1;
+    get_blk_attr(b[1], &length, &type, &eop);
+    swap_msg(b[1], length);
+    if (check_single_same(a[1], b[1]))
+        return -2;
+
+    free_blk(a[0]);
+    free_blk(a[1]);
+    free_blk(b[0]);
+    free_blk(b[1]);
+    return 0;
+}
+
+static int case102(void)
+{
+    char *a[2];
+    uint32_t *A;
+    uint32_t length;
+    uint32_t offset;
+    uint32_t avail;
+
+    uint32_t *tmp = alloc_tx_blk(QID_DATA);
+
+    pcxxSendStart();
+
+    produce_dl_src_data(tmp, QID_DATA);
+    length = sizeof(uint32_t) * (tmp[1] + 2);
+    RTE_ASSERT(0 == pcxxDataAlloc(length, &a[0], &offset));
+    memcpy(a[0], tmp, length);
+    pcxxDataSend(offset, length);
+
+
+    RTE_ASSERT(0 == pcxxCtrlAlloc(&a[1], &avail));
+    A = (uint32_t *)a[1];
+    produce_dl_src_data(A, QID_CTRL);
+    length = sizeof(uint32_t) * (A[1] + 2);
+    pcxxCtrlSend(a[1], length);
+
+    pcxxSendEnd();
+
+    while (-1 == pcxxCtrlRecv());
+
+    int re = atl_test_result;
+    atl_test_result = 0;
+    free_blk(tmp);
+    return re;
+}
+
+static int case3(void)
+{
+    uint32_t N;
+    uint32_t *a[3];
+    uint32_t *b[2];
+    uint32_t length = 0;
+    uint8_t type, eop;
+
+    a[0] = alloc_tx_blk(QID_DATA);
+    produce_dl_src_data(a[0], QID_DATA);
+    N = sizeof(uint32_t) * (a[0][1] + 2);
+    set_blk_attr(a[0], N, 0, 0);
+    tx_blks(QID_DATA, &a[0], 1);
+
+    a[1] = alloc_tx_blk(QID_DATA);
+    produce_dl_src_data(a[1], QID_DATA);
+    N = sizeof(uint32_t) * (a[1][1] + 2);
+    set_blk_attr(a[1], N, 0, 1);
+    tx_blks(QID_DATA, &a[1], 1);
+
+    a[2] = alloc_tx_blk(QID_CTRL);
+    produce_dl_src_data(a[2], QID_CTRL);
+    N = sizeof(uint32_t) * (a[2][1] + 2);
+    set_blk_attr(a[2], N, 1, 1);
+    tx_blks(QID_CTRL, &a[2], 1);
+
+    uint16_t s;
+    do {
+        s = rx_blks(QID_DATA, &b[0], 1);
+    } while(0 == s);
+    do {
+        s = rx_blks(QID_CTRL, &b[1], 1);
+    } while(0 == s);
+
+    get_blk_attr(b[0], &length, &type, &eop);
+    swap_msg(b[0], length);
+    if (check_same(&a[0], 2, b[0]))
+        return -1;
+    get_blk_attr(b[1], &length, &type, &eop);
+    swap_msg(b[1], length);
+    if (check_single_same(a[2], b[1]))
+        return -2;
+
+    free_blk(a[0]);
+    free_blk(a[1]);
+    free_blk(a[2]);
+    free_blk(b[0]);
+    free_blk(b[1]);
+    return 0;
+}
+
+static int case103(void)
+{
+    char *a[3];
+    uint32_t *A;
+    uint32_t length;
+    uint32_t offset;
+    uint32_t avail;
+
+    uint32_t *tmp = alloc_tx_blk(QID_DATA);
+
+    pcxxSendStart();
+
+    produce_dl_src_data(tmp, QID_DATA);
+    length = sizeof(uint32_t) * (tmp[1] + 2);
+    RTE_ASSERT(0 == pcxxDataAlloc(length, &a[0], &offset));
+    memcpy(a[0], tmp, length);
+    pcxxDataSend(offset, length);
+
+    produce_dl_src_data(tmp, QID_DATA);
+    length = sizeof(uint32_t) * (tmp[1] + 2);
+    RTE_ASSERT(0 == pcxxDataAlloc(length, &a[1], &offset));
+    memcpy(a[1], tmp, length);
+    pcxxDataSend(offset, length);
+
+
+    RTE_ASSERT(0 == pcxxCtrlAlloc(&a[2], &avail));
+    A = (uint32_t *)a[2];
+    produce_dl_src_data(A, QID_CTRL);
+    length = sizeof(uint32_t) * (A[1] + 2);
+    pcxxCtrlSend(a[2], length);
+
+    pcxxSendEnd();
+
+    while (-1 == pcxxCtrlRecv());
+
+    int re = atl_test_result;
+    atl_test_result = 0;
+    free_blk(tmp);
+    return re;
+}
+static int case4(uint16_t D)
+{
+    uint32_t N;
+    uint32_t *a[17];
+    uint32_t *b[2];
+    int k;
+    uint32_t length = 0;
+    uint8_t  type, eop;
+
+    if (D > 16) D = 16;
+
+    for (k = 0; k < D; k++) {
+        a[k] = alloc_tx_blk(QID_DATA);
+        produce_dl_src_data(a[k], QID_DATA);
+        N = sizeof(uint32_t) * (a[k][1] + 2);
+        eop = k == (D-1);
+        set_blk_attr(a[k], N, 0, eop);
+        //printf("  Type=0  m=%u  EOP=%1u\n", k, eop);
+        tx_blks(QID_DATA, &a[k], 1);
+    }
+    a[k] = alloc_tx_blk(QID_CTRL);
+    produce_dl_src_data(a[k], QID_CTRL);
+    N = sizeof(uint32_t) * (a[k][1] + 2);
+    set_blk_attr(a[k], N, 1, 1);
+    //printf("  Type=1  m=%u  EOP=1\n", k);
+    tx_blks(QID_CTRL, &a[k], 1);
+
+    uint16_t s;
+    do {
+        s = rx_blks(QID_DATA, &b[0], 1);
+    } while(0 == s);
+    do {
+        s = rx_blks(QID_CTRL, &b[1], 1);
+    } while(0 == s);
+
+    get_blk_attr(b[0], &length, &type, &eop);
+    swap_msg(b[0], length);
+    if (check_same(&a[0], D, b[0]))
+        return -1;
+    get_blk_attr(b[1], &length, &type, &eop);
+    swap_msg(b[1], length);
+    if (check_single_same(a[D], b[1]))
+        return -2;
+
+    for (k = 0; k < D; k++)
+        free_blk(a[k]);
+    free_blk(b[0]);
+    free_blk(b[1]);
+    return 0;
+}
+
+static int case104(uint16_t D)
+{
+    char *a[17];
+    uint32_t *A;
+    uint32_t length;
+    uint32_t offset;
+    uint32_t avail;
+    int k;
+
+    if (D > 16) D = 16;
+    uint32_t *tmp = alloc_tx_blk(QID_DATA);
+
+    pcxxSendStart();
+
+    for (k = 0; k < D; k++) {
+        produce_dl_src_data(tmp, QID_DATA);
+        length = sizeof(uint32_t) * (tmp[1] + 2);
+        RTE_ASSERT(0 == pcxxDataAlloc(length, &a[k], &offset));
+        memcpy(a[k], tmp, length);
+        pcxxDataSend(offset, length);
+    }
+
+    RTE_ASSERT(0 == pcxxCtrlAlloc(&a[k], &avail));
+    A = (uint32_t *)a[k];
+    produce_dl_src_data(A, QID_CTRL);
+    length = sizeof(uint32_t) * (A[1] + 2);
+    pcxxCtrlSend(a[k], length);
+
+    pcxxSendEnd();
+
+    while (-1 == pcxxCtrlRecv());
+
+    int re = atl_test_result;
+    atl_test_result = 0;
+    free_blk(tmp);
+    return re;
+}
+
+static int case5(void)
+{
+    uint32_t D;
+    uint32_t L = (uint32_t)rand();
+    L = 16 + (L & 7);
+
+    //printf("Case 5 will execute Case 4 for %u times!\n", L);
+    //n = 0;
+    while (L) {
+        D = (uint32_t)rand();
+        D = (D & 15) + 1;
+        L--;
+        //printf("... Test Case 4 with %u users for No. %u, Left %u times.\n", D, n++, L);
+        if (case4(D))
+            return -1;
+    }
+    return 0;
+}
+
+static int case105(void)
+{
+    uint32_t D;
+    uint32_t L = (uint32_t)rand();
+    L = 16 + (L & 7);
+
+    //printf("Case 105 will execute Case 104 for %u times!\n", L);
+    //n = 0;
+    while (L) {
+        D = (uint32_t)rand();
+        D = (D & 15) + 1;
+        L--;
+        //printf("... Test Case 104 with %u users for No. %u, Left %u times\n", D, n++, L);
+        if (case104(D))
+            return -1;
+    }
+    return 0;
+}
+
+static int case201(void)
+{
+    struct rte_mbuf *tx_pkts[16];
+    struct rte_mbuf *rx_pkts[16];
+    uint32_t n;
+    uint32_t N, M;
+    uint16_t offset;
+    uint8_t *tx_src_addr;
+    uint8_t *tx_dst_addr;
+    uint8_t *rx_dst_addr;
+    uint8_t *rx_src_addr;
+    uint16_t *tx_type;
+    uint16_t *rx_type;
+    uint16_t *tx_sdata;
+    uint32_t *tx_data;
+    uint8_t  *tx_cdata;
+    uint8_t  *rx_cdata;
+    uint16_t tx_length;
+    uint16_t rx_length;
+    uint16_t k;
+    uint8_t tdata;
+    uint8_t rdata;
+    int ret = 0;
+
+    N = (uint32_t)rand();
+    N = 1 + (N & 7);
+    for (n = 0; n < N; n++) {
+        tx_pkts[n] = rte_mbuf_raw_alloc(mpool_pc802_tx);
+        rte_pktmbuf_reset_headroom(tx_pkts[n]);
+
+        offset = 0;
+        tx_dst_addr = rte_pktmbuf_mtod_offset(tx_pkts[n], uint8_t *, offset);
+        offset += 6;
+        rte_eth_random_addr(tx_dst_addr);
+
+        tx_src_addr = rte_pktmbuf_mtod_offset(tx_pkts[n], uint8_t *, offset);
+        offset += 6;
+        rte_eth_random_addr(tx_src_addr);
+
+        tx_type = rte_pktmbuf_mtod_offset(tx_pkts[n], uint16_t *, offset);
+        offset += 2;
+        *tx_type = (uint16_t)rand();
+
+        tx_length = 46 + ((uint32_t)rand())% 1455;
+        tx_sdata = rte_pktmbuf_mtod_offset(tx_pkts[n], uint16_t *, offset);
+        offset += 2;
+        *tx_sdata = (uint16_t)rand();
+
+        tx_data = rte_pktmbuf_mtod_offset(tx_pkts[n], uint32_t *, offset);
+        for (k = 2; k < tx_length; k += sizeof(uint32_t))
+            *tx_data++ = (uint32_t)rand();
+
+        tx_pkts[n]->nb_segs = 1;
+        tx_pkts[n]->pkt_len = tx_pkts[n]->data_len = 14 + tx_length;
+        tx_pkts[n]->next = NULL;
+#if 0
+        DBLOG("TX-pkt[%u]: DST-Addr = %02X %02X %02X %02X %02X %02X\n",
+            n, tx_dst_addr[0], tx_dst_addr[1], tx_dst_addr[2],
+            tx_dst_addr[3], tx_dst_addr[4], tx_dst_addr[5]);
+        DBLOG("TX-pkt[%u]: SRC-Addr = %02X %02X %02X %02X %02X %02X\n",
+            n, tx_src_addr[0], tx_src_addr[1], tx_src_addr[2],
+            tx_src_addr[3], tx_src_addr[4], tx_src_addr[5]);
+        DBLOG("TX-pkt[%u]: Type = %04X, Data-Len = %u\n", n, *tx_type, tx_length);
+#endif
+    }
+    RTE_ASSERT(N == rte_eth_tx_burst(0, 0, tx_pkts, N));
+
+    k = 0;
+    M = N;
+    do {
+        n = rte_eth_rx_burst(0, 0, &rx_pkts[k], M);
+        k += n;
+        M -= n;
+    } while (M);
+
+    for (n = 0; n < N; n++) {
+        if (rx_pkts[n]->pkt_len != tx_pkts[n]->pkt_len) {
+            DBLOG("Wrong pkt %u: rx_pkt_len = %u, tx_pkt_len = %u\n",
+                n, rx_pkts[n]->pkt_len, tx_pkts[n]->pkt_len);
+            ret = -1;
+            break;
+        }
+
+        offset = 0;
+        tx_dst_addr = rte_pktmbuf_mtod_offset(tx_pkts[n], uint8_t *, offset);
+        rx_dst_addr = rte_pktmbuf_mtod_offset(rx_pkts[n], uint8_t *, offset);
+        offset += 6;
+
+        tx_src_addr = rte_pktmbuf_mtod_offset(tx_pkts[n], uint8_t *, offset);
+        rx_src_addr = rte_pktmbuf_mtod_offset(rx_pkts[n], uint8_t *, offset);
+        offset += 6;
+
+        for (k = 0; k < 6; k++) {
+            if (rx_dst_addr[k] != tx_src_addr[k]) {
+                DBLOG("Wrong pkt %u: rx_dst_addr[%hu] = 0x%02X tx_src_addr[%hu] = 0x%02X\n",
+                    n, k, rx_dst_addr[k], k, tx_src_addr[k]);
+                ret = -2;
+                break;
+            }
+        }
+        if (ret) break;
+
+        for (k = 0; k < 6; k++) {
+            if (rx_src_addr[k] != tx_dst_addr[k]) {
+                DBLOG("Wrong pkt %u: rx_src_addr[%hu] = 0x%02X tx_dst_addr[%hu] = 0x%02X\n",
+                    n, k, rx_src_addr[k], k, tx_dst_addr[k]);
+                ret = -3;
+                break;
+            }
+        }
+        if (ret) break;
+
+        tx_type = rte_pktmbuf_mtod_offset(tx_pkts[n], uint16_t *, offset);
+        rx_type = rte_pktmbuf_mtod_offset(rx_pkts[n], uint16_t *, offset);
+        offset += 2;
+        if (*tx_type != *rx_type) {
+            DBLOG("Wrong pkt %u: tx_type = 0x%04X rx_type = 0x%04X\n",
+                n, *tx_type, *rx_type);
+            ret = -4;
+            break;
+        }
+
+        tx_cdata = rte_pktmbuf_mtod_offset(tx_pkts[n], uint8_t *, offset);
+        rx_cdata = rte_pktmbuf_mtod_offset(rx_pkts[n], uint8_t *, offset);
+        k = 0;
+        rx_length = rx_pkts[n]->pkt_len - 14;
+        if (*tx_type == 0x0008) { //IP
+            uint16_t hlen = 20;
+            if (tx_cdata[9] == 0x17) //UDP
+                hlen += 8;
+            for (; k < hlen; k++) {
+                if (tx_cdata[k] != rx_cdata[k]) {
+                    DBLOG("Wrong pkt %u: IP/UDP Head: tx_data[%hu] = %02X rx_data[%hu] = %02X\n",
+                        n, k, tx_cdata[k], k, rx_cdata[k]);
+                    ret = -5;
+                    break;
+                }
+            }
+        }
+        if (ret) break;
+
+        for (; k < rx_length; k++) {
+            tdata = tx_cdata[k];
+            rdata = rx_cdata[k];
+			tdata++;
+            if (rdata != tdata) {
+                DBLOG("Wrong pkt %u: tx_cdata[%hu] = 0x%02X rx_cdata[%hu] = 0x%02X\n",
+                    n, k, tdata, k, rdata);
+                ret = -6;
+                break;
+            }
+        }
+        if (ret) break;
+        rte_pktmbuf_free(rx_pkts[n]);
+    }
+    for (; n < N; n++)
+        rte_pktmbuf_free(rx_pkts[n]);
+
+    return ret;
+}
+
+static int case301(void)
+{
+    char *a;
+    uint32_t *A;
+    uint32_t N;
+    uint32_t avail;
+
+    pcxxSendStart();
+    RTE_ASSERT(0 == pcxxOamAlloc(&a, &avail));
+    A = (uint32_t *)a;
+    produce_dl_src_data(A, QID_OAM);
+    N = sizeof(uint32_t) * (A[1] + 2);
+    pcxxOamSend(a, N);
+    pcxxSendEnd();
+
+    while (-1 == pcxxOamRecv());
+    int re = atl_test_result;
+    atl_test_result = 0;
+    return re;
+}
+
+extern cmdline_parse_ctx_t main_ctx[];
+static int prompt(void* arg)
+{
+    struct cmdline *cl;
+    arg = arg;
+
+    cl = cmdline_stdin_new(main_ctx, "PC802>> ");
+    if (cl == NULL) {
+        return -1;
+    }
+    cmdline_interact(cl);
+    cmdline_stdin_exit(cl);
+
+    return 0;
+}
+
+int test_case_No;
+
+#define disp_test_result(caseNo, result)  \
+    if (result) { \
+        DBLOG("Case %d --- FAILED\n", caseNo); \
+        break; \
+    } else { \
+        DBLOG("Case %d --- PASSED\n", caseNo); \
+    }
+
+#define disp_if_fail(caseNo, result) \
+    if (result) { \
+        DBLOG("Case %d --- FAILED\n", caseNo); \
+        break; \
+    }
+
+#define return_if_fail(case, result, looptimes) do {\
+        if (result) { \
+            DBLOG("Case %d -- FAILED -- Result = %d -- Loop = %u\n", case, result, looptimes); \
+            return -case; \
+        } \
+    } while(0)
+
+static int case_n1(void)
+{
+    int diag;
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case1();
+    return_if_fail(1, diag, 0);
+    diag = case2();
+    return_if_fail(2, diag, 0);
+    diag = case3();
+    return_if_fail(3, diag, 0);
+    diag = case4(16);
+    return_if_fail(4, diag, 0);
+    diag = case5();
+    return_if_fail(5, diag, 0);
+    diag = case101();
+    return_if_fail(101, diag, 0);
+    diag = case102();
+    return_if_fail(102, diag, 0);
+    diag = case103();
+    return_if_fail(103, diag, 0);
+    diag = case104(16);
+    return_if_fail(104, diag, 0);
+    diag = case105();
+    return_if_fail(105, diag, 0);
+    return 0;
+}
+
+static int case_n2(void)
+{
+    int diag;
+    diag = case201();
+    return_if_fail(201, diag, 0);
+    diag = case301();
+    return_if_fail(301, diag, 0);
+    diag = case1();
+    return_if_fail(1, diag, 0);
+    diag = case2();
+    return_if_fail(2, diag, 0);
+    diag = case3();
+    return_if_fail(3, diag, 0);
+    diag = case4(16);
+    return_if_fail(4, diag, 0);
+    return 0;
+}
+
+static int case_n800(void)
+{
+    uint32_t m, k;
+    int diag;
+    m = 0;
+    k = 0;
+    while (1) {
+        diag = case301();
+        return_if_fail(301, diag, k);
+        diag = case1();
+        return_if_fail(1, diag, k);
+        diag = case2();
+        return_if_fail(2, diag, k);
+        diag = case3();
+        return_if_fail(3, diag, k);
+        diag = case4(16);
+        return_if_fail(4, diag, k);
+        m++;
+        k++;
+        if (TEST_PC802_DISP_LOOP_NUM == m) {
+            DBLOG("Case -800 Passed %u Loops.\n", k);
+            m = 0;
+        }
+        pc802_check_dma_timeout(0);
+        if (testpc802_exit_loop) {
+            DBLOG("Case -800 Passed %u Loops.\n", k+1);
+            testpc802_exit_loop = 0;
+            return 0;
+        }
+    }
+    return 0;
+}
+
+static int case_n1000(void)
+{
+    uint32_t m, k, N;
+    int diag;
+    N = 100000;
+    m = 0;
+    for (k = 0; k < N; k++) {
+        diag = case201();
+        return_if_fail(201, diag, k);
+        diag = case301();
+        return_if_fail(301, diag, k);
+        diag = case1();
+        return_if_fail(1, diag, k);
+        diag = case2();
+        return_if_fail(2, diag, k);
+        diag = case3();
+        return_if_fail(3, diag, k);
+        diag = case4(16);
+        return_if_fail(4, diag, k);
+        m++;
+        if (TEST_PC802_DISP_LOOP_NUM == m) {
+            DBLOG("Case -1000 Passed %u Loops.\n", k+1);
+            m = 0;
+        }
+        pc802_check_dma_timeout(0);
+        if (testpc802_exit_loop) {
+            DBLOG("Case -1000 Passed %u Loops.\n", k+1);
+            testpc802_exit_loop = 0;
+            return 0;
+        }
+    }
+    return 0;
+}
+
+static int case_n802(void)
+{
+    uint32_t m, k;
+    int diag;
+    m = 0;
+    k = 0;
+    while (1) {
+        diag = case201();
+        return_if_fail(201, diag, k);
+        diag = case301();
+        return_if_fail(301, diag, k);
+        diag = case1();
+        return_if_fail(1, diag, k);
+        diag = case2();
+        return_if_fail(2, diag, k);
+        diag = case3();
+        return_if_fail(3, diag, k);
+        diag = case4(16);
+        return_if_fail(4, diag, k);
+        m++;
+        k++;
+        if (TEST_PC802_DISP_LOOP_NUM == m) {
+            DBLOG("Case -802 Passed %u Loops.\n", k);
+            m = 0;
+        }
+        pc802_check_dma_timeout(0);
+        if (testpc802_exit_loop) {
+            DBLOG("Case -802 Passed %u Loops.\n", k+1);
+            testpc802_exit_loop = 0;
+            return 0;
+        }
+    }
+    return 0;
+}
+
+static int case_n2000(void)
+{
+    uint32_t m, k, N;
+    int diag;
+    N = 1000000;
+    m = 0;
+    for (k = 0; k < N; k++) {
+        diag = case1();
+        return_if_fail(1, diag, k);
+        m++;
+        if (TEST_PC802_DISP_LOOP_NUM == m) {
+            DBLOG("Case 1 Passed %7d times.\n", k+1);
+            m = 0;
+        }
+        pc802_check_dma_timeout(0);
+        if (testpc802_exit_loop) {
+            DBLOG("Case -2000 Passed %u Loops.\n", k+1);
+            testpc802_exit_loop = 0;
+            return 0;
+        }
+    }
+    return 0;
+}
+
+static void run_case(int caseNo)
+{
+    int diag;
+    if (0 == caseNo)
+        return;
+    printf("Begin Test Case %d\n", caseNo);
+    switch(caseNo) {
+    case 1:
+        diag = case1();
+        disp_test_result(caseNo, diag);
+        break;
+    case 2:
+        diag = case2();
+        disp_test_result(caseNo, diag);
+        break;
+    case 3:
+        diag = case3();
+        disp_test_result(caseNo, diag);
+        break;
+    case 4:
+        diag = case4(16);
+        disp_test_result(caseNo, diag);
+        break;
+    case 5:
+        diag = case5();
+        disp_test_result(caseNo, diag);
+        break;
+    case 101:
+        diag = case101();
+        disp_test_result(caseNo, diag);
+        break;
+    case 102:
+        diag = case102();
+        disp_test_result(caseNo, diag);
+        break;
+    case 103:
+        diag = case103();
+        disp_test_result(caseNo, diag);
+        break;
+    case 104:
+        diag = case104(16);
+        disp_test_result(caseNo, diag);
+        break;
+    case 105:
+        diag = case105();
+        disp_test_result(caseNo, diag);
+        break;
+    case 201:
+        diag = case201();
+        disp_test_result(201, diag);
+        break;
+    case 301:
+        diag = case301();
+        disp_test_result(301, diag);
+        break;
+    case -1:
+        diag = case_n1();
+        disp_test_result(-1, diag);
+        break;
+    case -2:
+        diag = case_n2();
+        disp_test_result(-2, diag);
+        break;
+    case -800:
+        diag = case_n800();
+        disp_test_result(-800, diag);
+        break;
+    case -1000:
+        diag = case_n1000();
+        disp_test_result(-1000, diag);
+        break;
+    case -802:
+        diag = case_n802();
+        disp_test_result(-802, diag);
+        break;
+   case -2000:
+        diag = case_n2000();
+        disp_test_result(-2000, diag);
+        break;
+    default:
+        DBLOG("Wrong case number, it should be 1/2/3/4/5/101/102/103/104/105/-1/-2\n");
+    }
+    test_case_No = 0;
+}
+
+int main_stop = 0;
+
+void test_pc802_mem_dump(uint32_t          pc802_mem, uint32_t byte_num);
+
+void test_pc802_mem_dump(uint32_t          pc802_mem, uint32_t byte_num)
+{
+    uint32_t *pd = (uint32_t *)pc802_get_debug_mem(0);
+    uint32_t k, n;
+    if (byte_num > ((uint32_t)160 << 20)) {
+        DBLOG("The size for mem dump should be <= 160 M bytes !\n");
+        return;
+    }
+    uint64_t *p0 = rte_malloc("test_memdump", byte_num, 8);
+    if (NULL == p0) {
+        DBLOG("Out of memory!\n");
+        return;
+    }
+    for (n = k = 0; k < byte_num; k += sizeof(uint32_t), n++)
+        pd[n] = rand();
+    DBLOG("pd = %p p0 = %p\n", pd, p0);
+    memcpy(p0, pd, byte_num);
+    pc802_access_ep_mem(0, pc802_mem, byte_num, DIR_PCIE_DMA_DOWNLINK);
+
+    PC802_Mem_Block_t *mblk;
+    mblk = pc802_alloc_tx_mem_block(0, PC802_TRAFFIC_OAM);
+    if (NULL == mblk) {
+        DBLOG("Test MemDump Failed !\n");
+        return;
+    }
+    uint32_t *msg = (uint32_t *)&mblk[1];
+    msg[0] = 0x4b3c2d1e;
+    msg[1] = 0;
+    msg[2] = pc802_mem;
+    msg[3] = byte_num;
+    mblk->pkt_length = 16;
+    mblk->pkt_type = 2;
+    mblk->eop = 1;
+    pc802_tx_mblk_burst(0, PC802_TRAFFIC_OAM, &mblk, 1);
+
+    uint16_t P;
+    do {
+        P = pc802_rx_mblk_burst(0, PC802_TRAFFIC_OAM, &mblk, 1);
+    } while (0 == P);
+    msg = (uint32_t *)&mblk[1];
+    if (  (msg[0] != 0x4b3c2d1e)
+        ||(msg[1] != 0)
+        ||(msg[2] != pc802_mem)
+        ||(msg[3] != byte_num)) {
+        DBLOG("Test MemDump Failed !\n");
+        pc802_free_mem_block(mblk);
+        return;
+    }
+
+    memset(pd, 0, byte_num);
+
+    pc802_access_ep_mem(0, pc802_mem, byte_num, DIR_PCIE_DMA_UPLINK);
+
+    uint8_t *ps = (uint8_t *)p0;
+    uint8_t *pt = (uint8_t *)pd;
+    for (k = 0; k < byte_num; k++) {
+        if (ps[k] != pt[k]) {
+            DBLOG("Test MemDump Failed at k = %u !\n", k);
+            pc802_free_mem_block(mblk);
+            return;
+        }
+    }
+
+    pc802_free_mem_block(mblk);
+    rte_free(p0);
+
+    mblk = pc802_alloc_tx_mem_block(0, PC802_TRAFFIC_OAM);
+    if (NULL == mblk) {
+        DBLOG("Test MemDump Failed !\n");
+        return;
+    }
+    msg = (uint32_t *)&mblk[1];
+    msg[0] = 0x4b3c2d1e;
+    msg[1] = 100;
+    mblk->pkt_length = 8;
+    mblk->pkt_type = 2;
+    mblk->eop = 1;
+    pc802_tx_mblk_burst(0, PC802_TRAFFIC_OAM, &mblk, 1);
+
+    do {
+        P = pc802_rx_mblk_burst(0, PC802_TRAFFIC_OAM, &mblk, 1);
+    } while (0 == P);
+    msg = (uint32_t *)&mblk[1];
+    if (  (msg[0] != 0x4b3c2d1e)
+        ||(msg[1] != 100)) {
+        DBLOG("Test MemDump Failed !\n");
+        pc802_free_mem_block(mblk);
+        return;
+    }
+    pc802_free_mem_block(mblk);
+    DBLOG("Test memdump Passed when address = 0x%08X length = %u\n",
+        pc802_mem, byte_num);
+}
+
+int main(int argc, char** argv)
+{
+    int diag;
+
+    printf("%s\n", picocom_pc802_version());
+    printf("PC802 Driver Tester built AT %s ON %s\n", __TIME__, __DATE__);
+
+    signal(SIGINT, signal_handler);
+    signal(SIGTERM, signal_handler);
+
+    diag = rte_eal_init(argc, argv);
+    if (diag < 0)
+        rte_panic("Cannot init EAL\n");
+
+    port_init(0);
+
+    rte_eal_remote_launch(prompt, NULL, 1);
+
+    while(!main_stop) {
+        usleep(10);
+        run_case(test_case_No);
+    }
+
+    usleep(5000);
+
+    return 0;
+}
+
diff -ruN -x '*.data' dpdk-21.08/config/ppc/ppc64le-power8-linux-gcc npu_driver/pcie/user_space/DPDK/config/ppc/ppc64le-power8-linux-gcc
--- dpdk-21.08/config/ppc/ppc64le-power8-linux-gcc	2021-08-08 23:23:21.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/config/ppc/ppc64le-power8-linux-gcc	1970-01-01 08:00:00.000000000 +0800
@@ -1,11 +0,0 @@
-[binaries]
-c = 'powerpc64le-linux-gcc'
-cpp = 'powerpc64le-linux-cpp'
-ar = 'powerpc64le-linux-gcc-ar'
-strip = 'powerpc64le-linux-strip'
-
-[host_machine]
-system = 'linux'
-cpu_family = 'ppc64'
-cpu = 'power8'
-endian = 'little'
diff -ruN -x '*.data' dpdk-21.08/devtools/build-dict.sh npu_driver/pcie/user_space/DPDK/devtools/build-dict.sh
--- dpdk-21.08/devtools/build-dict.sh	2021-08-08 23:23:21.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/devtools/build-dict.sh	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-#! /bin/sh -e
-# SPDX-License-Identifier: BSD-3-Clause
-# Copyright 2020 Mellanox Technologies, Ltd
-
-# Build a spelling dictionary suitable for DPDK_CHECKPATCH_CODESPELL
-
-# path to local clone of https://github.com/codespell-project/codespell.git
-codespell_path=$1
-
-# concatenate codespell dictionaries, except GB/US one
-for suffix in .txt _code.txt _informal.txt _names.txt _rare.txt _usage.txt ; do
-	cat $codespell_path/codespell_lib/data/dictionary$suffix
-done |
-
-# remove too short or wrong checks
-sed '/^..->/d' |
-sed '/^uint->/d' |
-sed "/^doesn'->/d" |
-sed '/^wasn->/d' |
-
-# print to stdout
-cat
diff -ruN -x '*.data' dpdk-21.08/doc/guides/prog_guide/build-sdk-meson.rst npu_driver/pcie/user_space/DPDK/doc/guides/prog_guide/build-sdk-meson.rst
--- dpdk-21.08/doc/guides/prog_guide/build-sdk-meson.rst	2021-08-08 23:23:21.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/doc/guides/prog_guide/build-sdk-meson.rst	1970-01-01 08:00:00.000000000 +0800
@@ -1,217 +0,0 @@
-..  SPDX-License-Identifier: BSD-3-Clause
-    Copyright(c) 2018 Intel Corporation.
-
-Installing DPDK Using the meson build system
-============================================
-
-Summary
---------
-For many platforms, compiling and installing DPDK should work using the
-following set of commands::
-
-	meson build
-	cd build
-	ninja
-	ninja install
-
-This will compile DPDK in the ``build`` subdirectory, and then install the
-resulting libraries, drivers and header files onto the system - generally
-in /usr/local. A package-config file, ``libdpdk.pc``,  for DPDK will also
-be installed to allow ease of compiling and linking with applications.
-
-After installation, to use DPDK, the necessary CFLAG and LDFLAG variables
-can be got from pkg-config::
-
-	pkg-config --cflags libdpdk
-	pkg-config --libs libdpdk
-
-More detail on each of these steps can be got from the following sections.
-
-
-Getting the Tools
-------------------
-
-The ``meson`` tool is used to configure a DPDK build. On most Linux
-distributions this can be got using the local package management system,
-e.g. ``dnf install meson`` or ``apt-get install meson``. If meson is not
-available as a suitable package, it can also be installed using the Python
-3 ``pip`` tool, e.g. ``pip3 install meson``. Version 0.49.2 of meson is
-required - if the version packaged is too old, the latest version is
-generally available from "pip".
-
-The other dependency for building is the ``ninja`` tool, which acts similar
-to make and performs the actual build using information provided by meson.
-Installing meson will, in many cases, also install ninja, but, if not
-already installed, it too is generally packaged by most Linux distributions.
-If not available as a package, it can be downloaded as source or binary from
-https://ninja-build.org/
-
-It is best advised to go over the following links for the complete dependencies:
-
-* :doc:`Linux <../linux_gsg/sys_reqs>`
-* :doc:`FreeBSD <../freebsd_gsg/build_dpdk>`
-* :doc:`Windows <../windows_gsg/build_dpdk>`
-
-
-Configuring the Build
-----------------------
-
-To configure a build, run the meson tool, passing the path to the directory
-to be used for the build e.g. ``meson build``, as shown above. If calling
-meson from somewhere other than the root directory of the DPDK project the
-path to the root directory should be passed as the first parameter, and the
-build path as the second. For example, to build DPDK in /tmp/dpdk-build::
-
-	user@host:/tmp$ meson ~user/dpdk dpdk-build
-
-Meson will then configure the build based on settings in the project's
-meson.build files, and by checking the build environment for e.g. compiler
-properties or the presence of dependencies, such as libpcap, or openssl
-libcrypto libraries. Once done, meson writes a ``build.ninja`` file in the
-build directory to be used to do the build itself when ninja is called.
-
-Tuning of the build is possible, both as part of the original meson call,
-or subsequently using ``meson configure`` command (``mesonconf`` in some
-older versions). Some options, such as ``buildtype``, or ``werror`` are
-built into meson, while others, such as ``max_lcores``, or the list of
-examples to build, are DPDK-specific. To have a list of all options
-available run ``meson configure`` in the build directory.
-
-Examples of adjusting the defaults when doing initial meson configuration.
-Project-specific options are passed used -Doption=value::
-
-	meson --werror werrorbuild  # build with warnings as errors
-
-	meson --buildtype=debug debugbuild  # build for debugging
-
-	meson -Dexamples=l3fwd,l2fwd fwdbuild  # build some examples as
-					# part of the normal DPDK build
-
-	meson -Dmax_lcores=8 smallbuild  # scale build for smaller systems
-
-	meson -Denable_docs=true fullbuild  # build and install docs
-
-	meson -Dmachine=generic  # use builder-independent baseline -march
-
-	meson -Ddisable_drivers=event/*,net/tap  # disable tap driver and all
-					# eventdev PMDs for a smaller build
-
-	meson -Denable_trace_fp=true tracebuild # build with fast path traces
-					# enabled
-
-Examples of setting some of the same options using meson configure::
-
-	meson configure -Dwerror=true
-
-	meson configure -Dbuildtype=debug
-
-	meson configure -Dexamples=l3fwd,l2fwd
-
-	meson configure -Dmax_lcores=8
-
-	meson configure -Denable_trace_fp=true
-
-.. note::
-
-        once meson has been run to configure a build in a directory, it
-        cannot be run again on the same directory. Instead ``meson configure``
-        should be used to change the build settings within the directory, and when
-        ``ninja`` is called to do the build itself, it will trigger the necessary
-        re-scan from meson.
-
-.. note::
-        machine=generic uses a config that works on all supported architectures
-        regardless of the capabilities of the machine where the build is happening.
-
-As well as those settings taken from ``meson configure``, other options
-such as the compiler to use can be passed via environment variables. For
-example::
-
-	CC=clang meson clang-build
-
-.. note::
-
-        for more comprehensive overriding of compilers or other environment
-        settings, the tools for cross-compilation may be considered. However, for
-        basic overriding of the compiler etc., the above form works as expected.
-
-
-Performing the Build
----------------------
-
-Use ``ninja`` to perform the actual build inside the build folder
-previously configured. In most cases no arguments are necessary.
-
-Ninja accepts a number of flags which are similar to make. For example, to
-call ninja from outside the build folder, you can use ``ninja -C build``.
-Ninja also runs parallel builds by default, but you can limit this using
-the ``-j`` flag, e.g. ``ninja -j1 -v`` to do the build one step at a time,
-printing each command on a new line as it runs.
-
-
-Installing the Compiled Files
-------------------------------
-
-Use ``ninja install`` to install the required DPDK files onto the system.
-The install prefix defaults to ``/usr/local`` but can be used as with other
-options above. The environment variable ``DESTDIR`` can be used to adjust
-the root directory for the install, for example when packaging.
-
-With the base install directory, the individual directories for libraries
-and headers are configurable. By default, the following will be the
-installed layout::
-
-	headers -> /usr/local/include
-	libraries -> /usr/local/lib64
-	drivers -> /usr/local/lib64/dpdk/drivers
-	libdpdk.pc -> /usr/local/lib64/pkgconfig
-
-For the drivers, these will also be symbolically linked into the library
-install directory, so that ld.so can find them in cases where one driver may
-depend on another, e.g. a NIC PMD depending upon the PCI bus driver. Within
-the EAL, the default search path for drivers will be set to the configured
-driver install path, so dynamically-linked applications can be run without
-having to pass in ``-d /path/to/driver`` options for standard drivers.
-
-
-Cross Compiling DPDK
---------------------
-
-To cross-compile DPDK on a desired target machine we can use the following
-command::
-
-	meson cross-build --cross-file <target_machine_configuration>
-
-For example if the target machine is arm64 we can use the following
-command::
-
-        meson arm-build --cross-file config/arm/arm64_armv8_linux_gcc
-
-where config/arm/arm64_armv8_linux_gcc contains settings for the compilers
-and other build tools to be used, as well as characteristics of the target
-machine.
-
-Using the DPDK within an Application
--------------------------------------
-
-To compile and link against DPDK within an application, pkg-config should
-be used to query the correct parameters. Examples of this are given in the
-makefiles for the example applications included with DPDK. They demonstrate
-how to link either against the DPDK shared libraries, or against the static
-versions of the same.
-
-From examples/helloworld/Makefile::
-
-	PC_FILE := $(shell pkg-config --path libdpdk)
-	CFLAGS += -O3 $(shell pkg-config --cflags libdpdk)
-	LDFLAGS_SHARED = $(shell pkg-config --libs libdpdk)
-	LDFLAGS_STATIC = $(shell pkg-config --static --libs libdpdk)
-
-	build/$(APP)-shared: $(SRCS-y) Makefile $(PC_FILE) | build
-		$(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS) $(LDFLAGS_SHARED)
-
-	build/$(APP)-static: $(SRCS-y) Makefile $(PC_FILE) | build
-		$(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS) $(LDFLAGS_STATIC)
-
-	build:
-		@mkdir -p $@
diff -ruN -x '*.data' dpdk-21.08/drivers/net/meson.build npu_driver/pcie/user_space/DPDK/drivers/net/meson.build
--- dpdk-21.08/drivers/net/meson.build	2021-08-08 23:23:21.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/meson.build	2022-01-21 11:52:16.295570201 +0800
@@ -47,6 +47,7 @@
         'octeontx2',
         'octeontx_ep',
         'pcap',
+        'pc802',
         'pfe',
         'qede',
         'ring',
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/meson.build npu_driver/pcie/user_space/DPDK/drivers/net/pc802/meson.build
--- dpdk-21.08/drivers/net/pc802/meson.build	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/meson.build	2022-01-21 11:52:16.354570204 +0800
@@ -0,0 +1,20 @@
+# Copyright(c) 2020 PICOCOM Corporation
+
+if is_windows
+    build = false
+    reason = 'not supported on Windows'
+    subdir_done()
+endif
+
+cflags += '-DRTE_ENABLE_ASSERT'
+
+sources = files(
+        'pc802_ethdev.c',
+        'pc802_logs.c',
+        'pcxx_ipc.c',
+)
+
+headers = files(
+        'rte_pmd_pc802.h',
+        'pcxx_ipc.h'
+)
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pc802_common.h npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_common.h
--- dpdk-21.08/drivers/net/pc802/pc802_common.h	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_common.h	2022-01-21 11:52:16.355570204 +0800
@@ -0,0 +1,227 @@
+#ifndef __PC802_COMMON_H__
+#define __PC802_COMMON_H__
+
+#include <stdint.h>
+#include <stddef.h>
+
+#define DIR_PCIE_DMA_DOWNLINK   1
+#define DIR_PCIE_DMA_UPLINK     0
+
+#define MIN_DESC_NUM    8
+#define MAX_DESC_NUM  128
+
+typedef enum PC802_Traffic_Type_e {
+    PC802_TRAFFIC_ETHERNET,
+    PC802_TRAFFIC_5G_EMBB_DATA,
+    PC802_TRAFFIC_5G_EMBB_CTRL,
+    PC802_TRAFFIC_5G_URLLC,
+    PC802_TRAFFIC_4G_LTE_DATA,
+    PC802_TRAFFIC_4G_LTE_CTRL,
+    PC802_TRAFFIC_OAM,
+    PC802_TRAFFIC_NUM
+} PC802_Traffic_Type_e;
+
+#define MAX_DL_CH_NUM   PC802_TRAFFIC_NUM
+#define MAX_UL_CH_NUM   PC802_TRAFFIC_NUM
+
+#define DEFAULT_PC802_5G_DESC_NUM   256
+
+#define PC802_CACHE_LINE_SZ 32
+
+struct PC802_CacheLine_t{
+    uint32_t _a[8];
+} __attribute__((__aligned__(PC802_CACHE_LINE_SZ)));
+
+typedef struct PC802_CacheLine_t PC802_CacheLine_t;
+
+typedef struct PC802_BAR_t {
+    union {
+        PC802_CacheLine_t _cahce_line;
+        struct {
+            uint32_t DEVEN;
+            uint32_t DEVRDY;
+            uint32_t DBAL;
+            uint32_t DBAH;
+            uint32_t ULDMAN;
+        };
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_tdnum;
+        uint32_t TDNUM[PC802_TRAFFIC_NUM];
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_trccnt;
+        uint32_t TRCCNT[PC802_TRAFFIC_NUM];
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_tepcnt;
+        uint32_t TEPCNT[PC802_TRAFFIC_NUM];
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_rdnum;
+        uint32_t RDNUM[PC802_TRAFFIC_NUM];
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_rrccnt;
+        uint32_t RRCCNT[PC802_TRAFFIC_NUM];
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_repcnt;
+        uint32_t REPCNT[PC802_TRAFFIC_NUM];
+    };
+	union {
+        PC802_CacheLine_t _cahce_line_brccnt;
+		struct {
+			uint32_t BOOTSRCL;
+			uint32_t BOOTSRCH;
+			uint32_t BOOTDST;
+			uint32_t BOOTSZ;
+			uint32_t BOOTRCCNT;
+			uint32_t BOOTRSPL;
+			uint32_t BOOTRSPH;
+		};
+    };
+	union {
+        PC802_CacheLine_t _cahce_line_bepcnt;
+		struct {
+			uint32_t BOOTEPCNT;
+			uint32_t BOOTERROR;
+		};
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_macaddr;
+        struct {
+            uint32_t MACADDRL;
+        };
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_debug_rcm;
+        struct {
+            uint32_t DBGRCAL;
+            uint32_t DBGRCAH;
+        };
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_debug_rcc;
+        struct {
+            uint32_t DBGEPADDR;
+            uint32_t DBGBYTESNUM;
+            uint32_t DBGCMD;
+            uint32_t DBGRCCNT;
+        };
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_debug_ep;
+        uint32_t DBGEPCNT;
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_sync_ecpri;
+        struct {
+            uint32_t DRVSTATE;
+            uint32_t MEMCFGADDR;
+        };
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_ul_dma;
+        struct {
+            uint32_t ULDMA_TIMEOUT_FINISHED[4];
+            uint32_t ULDMA_TIMEOUT_ERROR[4];
+        };
+    };
+    union {
+        PC802_CacheLine_t _cahce_line_dl_dma;
+        struct {
+            uint32_t DLDMA_TIMEOUT_FINISHED[4];
+            uint32_t DLDMA_TIMEOUT_ERROR[4];
+        };
+    };
+} PC802_BAR_t;
+
+#define PC802_DEVEN             (offsetof(PC802_BAR_t,   DEVEN))
+#define PC802_DEVRDY            (offsetof(PC802_BAR_t,   DEVRDY))
+#define PC802_DBAL              (offsetof(PC802_BAR_t,   DBAL))
+#define PC802_DBAH              (offsetof(PC802_BAR_t,   DBAH))
+
+#define PC802_TDNUM(n)          (offsetof(PC802_BAR_t, TDNUM[0]) + sizeof(uint32_t) * (n))
+#define PC802_TRCCNT(n)         (offsetof(PC802_BAR_t, TRCCNT[0]) + sizeof(uint32_t) * (n))
+#define PC802_TEPCNT(n)         (offsetof(PC802_BAR_t, TEPCNT[0]) + sizeof(uint32_t) * (n))
+
+#define PC802_RDNUM(n)          (offsetof(PC802_BAR_t, RDNUM[0]) + sizeof(uint32_t) * (n))
+#define PC802_RRCCNT(n)         (offsetof(PC802_BAR_t, RRCCNT[0]) + sizeof(uint32_t) * (n))
+#define PC802_REPCNT(n)         (offsetof(PC802_BAR_t, REPCNT[0]) + sizeof(uint32_t) * (n))
+
+
+#define NPU_CACHE_LINE_SZ   64
+
+typedef struct stPC802_Descriptor_t{
+    uint64_t phy_addr;  // pointer to start physical address of a buffer in NPU memory
+    uint32_t length;    // length of content to be sent in bytes
+    uint8_t  eop;       // end of packet, 0=not the last descriptor for a whole message, 1=last descriptor
+    uint8_t  type;      // packet type, 1=control, 0=data, this field is not used for Ethernet
+} PC802_Descriptor_t;
+
+struct stPC802_EP_Counter_Mirror_t {
+    union {
+        PC802_CacheLine_t   cache_line_tepcnt;
+        volatile uint32_t TEPCNT[MAX_DL_CH_NUM];
+    };
+    union {
+        PC802_CacheLine_t   cache_line_repcnt;
+        volatile uint32_t REPCNT[MAX_UL_CH_NUM];
+    };
+} __attribute__((__aligned__(NPU_CACHE_LINE_SZ)));
+
+typedef struct stPC802_EP_Counter_Mirror_t PC802_EP_Counter_Mirror_t;
+
+typedef struct PC802_Descs_t {
+    PC802_Descriptor_t  dl[MAX_DL_CH_NUM][MAX_DESC_NUM];
+    PC802_Descriptor_t  ul[MAX_UL_CH_NUM][MAX_DESC_NUM];
+    PC802_EP_Counter_Mirror_t  mr;
+} PC802_Descs_t;
+
+static inline uint32_t get_dl_desc_offset(uint32_t ch, uint32_t idx)
+{
+    return (ch * MAX_DESC_NUM + idx) * sizeof(PC802_Descriptor_t);
+}
+
+static inline uint32_t get_ul_desc_offset(uint32_t ch, uint32_t idx)
+{
+    return (MAX_DL_CH_NUM * MAX_DESC_NUM + ch * MAX_DESC_NUM + idx) * sizeof(PC802_Descriptor_t);
+}
+
+static inline uint32_t get_ep_counter_mirror_offset(void)
+{
+    return (MAX_DL_CH_NUM + MAX_UL_CH_NUM) * MAX_DESC_NUM * sizeof(PC802_Descriptor_t);
+}
+
+static inline int isPowerOf2(uint32_t n)
+{
+    return n && !(n & (n - 1));
+}
+
+#define  DBLOG(format, ...) \
+    printf("%s : %u : " format, __func__, __LINE__, ##__VA_ARGS__)
+
+struct PC802_BAR_Ext_t {
+    union {
+        uint32_t _a0[16];
+        struct {
+            volatile uint32_t MB_EPCNT;
+            uint32_t MB_COMMAND;
+            uint32_t MB_ARGS[14];
+        };
+    };
+    union {
+        uint32_t _a1[8];
+        struct {
+            uint32_t MB_RCCNT;
+            uint32_t MB_RESULT;
+        };
+    };
+} __attribute__((__aligned__(32)));
+
+typedef struct PC802_BAR_Ext_t  PC802_BAR_Ext_t;
+
+
+
+#endif
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pc802_ethdev.c npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_ethdev.c
--- dpdk-21.08/drivers/net/pc802/pc802_ethdev.c	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_ethdev.c	2022-01-21 11:52:16.355570204 +0800
@@ -0,0 +1,1841 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018-2020 Picocom Corporation
+ */
+
+#include <sys/queue.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include <rte_common.h>
+#include <rte_interrupts.h>
+#include <rte_byteorder.h>
+#include <rte_debug.h>
+#include <rte_pci.h>
+#include <rte_bus_pci.h>
+#include <rte_ether.h>
+#include <ethdev_driver.h>
+#include <ethdev_pci.h>
+#include <rte_memory.h>
+#include <rte_eal.h>
+#include <rte_malloc.h>
+#include <rte_dev.h>
+
+#include "pc802_logs.h"
+#include "pc802_ethdev.h"
+
+#define PCI_VENDOR_PICOCOM          0x1EC4
+#define PCI_DEVICE_PICOCOM_PC802    0x1001
+
+static PC802_BAR_t *gbar;
+
+static const struct rte_pci_id pci_id_pc802_map[] = {
+    { RTE_PCI_DEVICE(PCI_VENDOR_PICOCOM, PCI_DEVICE_PICOCOM_PC802) },
+    { .vendor_id = 0, /* sentinel */ },
+};
+
+typedef struct PC802_Mem_Pool_t {
+    PC802_Mem_Block_t *first;
+    uint32_t block_size;
+    uint32_t block_num;
+} PC802_Mem_Pool_t;
+
+struct pmd_queue_stats {
+    uint64_t pkts;
+    uint64_t bytes;
+    uint64_t err_pkts;
+};
+
+/**
+ * Structure associated with each descriptor of the RX ring of a RX queue.
+ */
+struct pc802_rx_entry {
+    union {
+        struct rte_mbuf *mbuf; /**< mbuf associated with RX descriptor. */
+        PC802_Mem_Block_t *mblk;
+    };
+};
+
+/**
+ * Structure associated with each RX queue.
+ */
+struct pc802_rx_queue {
+    struct rte_mempool  *mb_pool;   /**< mbuf pool to populate RX ring. */
+    volatile PC802_Descriptor_t *rx_ring; /**< RX ring virtual address. */
+    struct pc802_rx_entry *sw_ring;   /**< address of RX software ring. */
+    //uint64_t            rx_ring_phys_addr; /**< RX ring DMA address. */
+    volatile uint32_t   *rrccnt_reg_addr; /**< RDT register address. */
+    volatile uint32_t   *repcnt_mirror_addr;
+    //volatile uint32_t   *repcnt_reg_addr; /**< RDH register address. */
+    //struct rte_mbuf *pkt_first_seg; /**< First segment of current packet. */
+    //struct rte_mbuf *pkt_last_seg;  /**< Last segment of current packet. */
+    //uint64_t      offloads;   /**< Offloads of DEV_RX_OFFLOAD_* */
+    PC802_Mem_Pool_t    mpool;
+    uint32_t            rc_cnt;
+    //uint32_t            ep_cnt;
+    uint16_t            nb_rx_desc; /**< number of RX descriptors. */
+    //uint16_t            rx_tail;    /**< current value of RDT register. */
+    uint16_t            nb_rx_hold; /**< number of held free RX desc. */
+    uint16_t            rx_free_thresh; /**< max free RX desc to hold. */
+    uint16_t            queue_id;   /**< RX queue index. */
+    uint16_t            port_id;    /**< Device port identifier. */
+    //uint8_t             pthresh;    /**< Prefetch threshold register. */
+    //uint8_t             hthresh;    /**< Host threshold register. */
+    //uint8_t             wthresh;    /**< Write-back threshold register. */
+    //uint8_t             crc_len;    /**< 0 if CRC stripped, 4 otherwise. */
+    struct pmd_queue_stats  stats;
+};
+
+/**
+ * Structure associated with each descriptor of the TX ring of a TX queue.
+ */
+struct pc802_tx_entry {
+    union {
+        struct {
+            struct rte_mbuf *mbuf; /**< mbuf associated with TX desc, if any. */
+            //uint16_t next_id; /**< Index of next descriptor in ring. */
+            //uint16_t last_id; /**< Index of last scattered descriptor. */
+        };
+        PC802_Mem_Block_t *mblk;
+   };
+};
+
+/**
+ * Structure associated with each TX queue.
+ */
+struct pc802_tx_queue {
+    volatile PC802_Descriptor_t *tx_ring; /**< TX ring address */
+    //uint64_t               tx_ring_phys_addr; /**< TX ring DMA address. */
+    struct pc802_tx_entry    *sw_ring; /**< virtual address of SW ring. */
+    volatile uint32_t      *trccnt_reg_addr; /**< Address of TDT register. */
+    volatile uint32_t      *tepcnt_mirror_addr;
+    //uint32_t               ep_cnt;
+    PC802_Mem_Pool_t            mpool;
+    uint32_t               rc_cnt;  /**< Current value of TDT register. */
+    uint16_t               nb_tx_desc;    /**< number of TX descriptors. */
+    /**< Start freeing TX buffers if there are less free descriptors than
+         this value. */
+    uint16_t               tx_free_thresh;
+    /**< Number of TX descriptors to use before RS bit is set. */
+    //uint16_t               tx_rs_thresh;
+    /** Number of TX descriptors used since RS bit was set. */
+    //uint16_t               nb_tx_used;
+    /** Total number of TX descriptors ready to be allocated. */
+    uint16_t               nb_tx_free;
+    uint16_t               queue_id; /**< TX queue index. */
+    uint16_t               port_id;  /**< Device port identifier. */
+    //uint8_t                pthresh;  /**< Prefetch threshold register. */
+    //uint8_t                hthresh;  /**< Host threshold register. */
+    //uint8_t                wthresh;  /**< Write-back threshold register. */
+    //struct em_ctx_info ctx_cache;
+    /**< Hardware context history.*/
+    //uint64_t         offloads; /**< offloads of DEV_TX_OFFLOAD_* */
+    struct pmd_queue_stats  stats;
+};
+
+struct pc802_adapter {
+    uint8_t *bar0_addr;
+    PC802_Descs_t *pDescs;
+    uint64_t descs_phy_addr;
+    struct pc802_tx_queue  txq[MAX_DL_CH_NUM];
+    struct pc802_rx_queue  rxq[MAX_UL_CH_NUM];
+    struct rte_ether_addr eth_addr;
+    uint8_t started;
+    uint8_t stopped;
+
+    uint64_t *dbg;
+    uint32_t dbg_rccnt;
+};
+
+#define PC802_DEV_PRIVATE(adapter)  ((struct pc802_adapter *)adapter)
+
+#define DIR_PCIE_DMA_DOWNLINK   1
+#define DIR_PCIE_DMA_UPLINK     0
+static PC802_BAR_Ext_t * pc802_get_BAR_Ext(uint16_t port);
+static void * pc802_process_phy_test_vectors(void *data);
+static uint32_t handle_vec_read(    uint32_t file_id, uint32_t offset, uint32_t address, uint32_t length);
+static uint32_t handle_vec_dump(uint32_t file_id, uint32_t address, uint32_t length);
+
+PC802_BAR_t * pc802_get_BAR(uint16_t port_id)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+	return bar;
+}
+
+int pc802_get_socket_id(uint16_t port_id)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+	return dev->data->numa_node;
+}
+
+int pc802_create_rx_queue(uint16_t port_id, uint16_t queue_id, uint32_t block_size, uint32_t block_num, uint16_t nb_desc)
+{
+    if (!isPowerOf2(nb_desc) || (nb_desc > MAX_DESC_NUM) || (nb_desc < MIN_DESC_NUM))
+        return -EINVAL;
+    if (block_num <= nb_desc)
+        return -EINVAL;
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    struct pc802_rx_queue *rxq = &adapter->rxq[queue_id];
+    volatile PC802_Descriptor_t *rxdp;
+    struct pc802_rx_entry *rxep;
+    uint32_t mask = NPU_CACHE_LINE_SZ - 1;
+    uint32_t k;
+    int socket_id = dev->device->numa_node;
+    char z_name[RTE_MEMZONE_NAMESIZE];
+    const struct rte_memzone *mz;
+    PC802_Mem_Block_t *mblk;
+
+    rxq->mpool.block_size = block_size;
+    rxq->mpool.block_num = block_num;
+
+    block_size = (block_size + mask) & (~mask);
+    //block_size += sizeof(PC802_Mem_Block_t);
+
+    /* Allocate software ring. */
+    if ((rxq->sw_ring = rte_zmalloc("rxq->sw_ring",
+            sizeof (rxq->sw_ring[0]) * nb_desc,
+            RTE_CACHE_LINE_SIZE)) == NULL) {
+        return -ENOMEM;
+    }
+
+    rxq->mpool.first = NULL;
+    for (k = 0; k < block_num; k++) {
+        snprintf(z_name, sizeof(z_name), "PC802Rx_%2d_%2d_%4d",
+              dev->data->port_id, queue_id, k);
+        mz = rte_memzone_reserve(z_name, block_size, socket_id, RTE_MEMZONE_IOVA_CONTIG);
+        if (mz == NULL)
+            return -ENOMEM;
+        mblk = (PC802_Mem_Block_t *)mz->addr;
+        mblk->buf_phy_addr = mz->iova + sizeof(PC802_Mem_Block_t);
+        mblk->pkt_length = 0;
+        mblk->next = rxq->mpool.first;
+        mblk->first = &rxq->mpool.first;
+        mblk->alloced = 0;
+        rxq->mpool.first = mblk;
+        DBLOG("UL MZ[%1u][%3u]: PhyAddr=0x%lX VirtulAddr=%p\n",
+            queue_id, k, mz->iova, mz->addr);
+        DBLOG("UL MBlk[%1u][%3u]: PhyAddr=0x%lX VirtAddr=%p\n",
+            queue_id, k, mblk->buf_phy_addr, &mblk[1]);
+    }
+
+    rxdp = rxq->rx_ring = adapter->pDescs->ul[queue_id];
+    rxep = rxq->sw_ring;
+    for (k = 0; k < nb_desc; k++) {
+        rxep->mblk = rxq->mpool.first;
+        rxq->mpool.first = rxep->mblk->next;
+        rxep->mblk->next = NULL;
+        rxep->mblk->alloced = 1;
+        rxdp->phy_addr = rxep->mblk->buf_phy_addr;
+        rxdp->length = 0;
+        DBLOG("UL DESC[%1u][%3u].phy_addr=0x%lX\n", queue_id, k, rxdp->phy_addr);
+        rxep++;
+        rxdp++;
+    }
+
+    rxq->rrccnt_reg_addr = (volatile uint32_t *)&bar->RRCCNT[queue_id];
+    rxq->repcnt_mirror_addr = &adapter->pDescs->mr.REPCNT[queue_id];
+    rxq->nb_rx_desc = nb_desc;
+    rxq->rc_cnt = 0;
+    rxq->nb_rx_hold = 0;
+    rxq->rx_free_thresh = 32;
+    rxq->queue_id = queue_id;
+    rxq->port_id = port_id;
+
+    PC802_WRITE_REG(bar->RDNUM[queue_id], nb_desc);
+    PC802_WRITE_REG(bar->RRCCNT[queue_id], 0);
+
+    return 0;
+}
+
+int pc802_create_tx_queue(uint16_t port_id, uint16_t queue_id, uint32_t block_size, uint32_t block_num, uint16_t nb_desc)
+{
+    if (!isPowerOf2(nb_desc) || (nb_desc > MAX_DESC_NUM) || (nb_desc < MIN_DESC_NUM))
+        return -EINVAL;
+    if (block_num <= nb_desc)
+        return -EINVAL;
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    struct pc802_tx_queue *txq = &adapter->txq[queue_id];
+    struct pc802_tx_entry *txep;
+    uint32_t mask = NPU_CACHE_LINE_SZ - 1;
+    uint32_t k;
+    int socket_id = dev->device->numa_node;
+    char z_name[RTE_MEMZONE_NAMESIZE];
+    const struct rte_memzone *mz;
+    PC802_Mem_Block_t *mblk;
+
+    txq->mpool.block_size = block_size;
+    txq->mpool.block_num = block_num;
+
+    block_size = (block_size + mask) & (~mask);
+    //block_size += sizeof(PC802_Mem_Block_t);
+
+    /* Allocate software ring. */
+    if ((txq->sw_ring = rte_zmalloc("txq->sw_ring",
+            sizeof (txq->sw_ring[0]) * nb_desc,
+            RTE_CACHE_LINE_SIZE)) == NULL) {
+        return -ENOMEM;
+    }
+
+    txq->mpool.first = NULL;
+    for (k = 0; k < block_num; k++) {
+        snprintf(z_name, sizeof(z_name), "PC802Tx_%2d_%2d_%4d",
+              dev->data->port_id, queue_id, k);
+        mz = rte_memzone_reserve(z_name, block_size, socket_id, RTE_MEMZONE_IOVA_CONTIG);
+        if (mz == NULL)
+            return -ENOMEM;
+        mblk = (PC802_Mem_Block_t *)mz->addr;
+        mblk->buf_phy_addr = mz->iova + sizeof(PC802_Mem_Block_t);
+        mblk->pkt_length = 0;
+        mblk->next = txq->mpool.first;
+        mblk->first = &txq->mpool.first;
+        mblk->alloced = 0;
+        txq->mpool.first = mblk;
+        DBLOG("DL MZ[%1u][%3u]: PhyAddr=0x%lX VirtulAddr=%p\n",
+            queue_id, k, mz->iova, mz->addr);
+        DBLOG("DL MBlk[%1u][%3u]: PhyAddr=0x%lX VirtAddr=%p\n",
+            queue_id, k, mblk->buf_phy_addr, &mblk[1]);
+    }
+
+    txq->tx_ring = adapter->pDescs->dl[queue_id];
+    txep = txq->sw_ring;
+    for (k = 0; k < nb_desc; k++) {
+        txep->mblk = NULL;
+        txep++;
+    }
+
+    txq->trccnt_reg_addr = (volatile uint32_t *)&bar->TRCCNT[queue_id];
+    txq->tepcnt_mirror_addr = &adapter->pDescs->mr.TEPCNT[queue_id];
+    txq->nb_tx_desc = nb_desc;
+    txq->rc_cnt = 0;
+    txq->nb_tx_free = nb_desc;
+    txq->tx_free_thresh = 32;
+    txq->queue_id = queue_id;
+    txq->port_id = port_id;
+
+    PC802_WRITE_REG(bar->TRCCNT[queue_id], 0);
+    PC802_WRITE_REG(bar->TDNUM[queue_id], nb_desc);
+
+    return 0;
+}
+
+PC802_Mem_Block_t * pc802_alloc_tx_mem_block(uint16_t port_id, uint16_t queue_id)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_tx_queue *txq = &adapter->txq[queue_id];
+    PC802_Mem_Block_t *mblk;
+    mblk = txq->mpool.first;
+    if (NULL != mblk) {
+        txq->mpool.first = mblk->next;
+        mblk->next = NULL;
+        mblk->alloced = 1;
+    }
+    return mblk;
+}
+
+void pc802_free_mem_block(PC802_Mem_Block_t *mblk)
+{
+    if (NULL == mblk)
+        return;
+    if (mblk->alloced == 0)
+        return;
+    mblk->next = *mblk->first;
+    *mblk->first = mblk;
+    mblk->alloced = 0;
+    return;
+}
+
+uint16_t pc802_rx_mblk_burst(uint16_t port_id, uint16_t queue_id,
+    PC802_Mem_Block_t **rx_blks, uint16_t nb_blks)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_rx_queue *rxq = &adapter->rxq[queue_id];
+    volatile PC802_Descriptor_t *rx_ring;
+    volatile PC802_Descriptor_t *rxdp;
+    struct pc802_rx_entry *sw_ring;
+    PC802_Mem_Block_t *rxm;
+    PC802_Mem_Block_t *nmb;
+    uint32_t mask = rxq->nb_rx_desc - 1;
+    uint32_t idx;
+    uint32_t ep_txed;
+    uint32_t rx_id;
+    uint16_t nb_rx;
+    uint16_t nb_hold;
+
+    nb_rx = 0;
+    nb_hold = rxq->nb_rx_hold;
+    rx_id = rxq->rc_cnt;
+    rx_ring = rxq->rx_ring;
+    sw_ring = rxq->sw_ring;
+    ep_txed = *rxq->repcnt_mirror_addr - rx_id;
+    nb_blks = (ep_txed < nb_blks) ? ep_txed : nb_blks;
+    while (nb_rx < nb_blks) {
+        idx = rx_id & mask;
+        rxdp = &rx_ring[idx];
+
+        nmb = rxq->mpool.first;
+        if (nmb == NULL) {
+            PMD_RX_LOG(DEBUG, "RX mblk alloc failed port_id=%u "
+                   "queue_id=%u",
+                   (unsigned) rxq->port_id,
+                   (unsigned) rxq->queue_id);
+            break;
+        }
+        rxq->mpool.first = nmb->next;
+        nmb->next = NULL;
+        nmb->alloced = 1;
+
+        rxm = sw_ring[idx].mblk;
+        rte_prefetch0(rxm);
+
+        if ((idx & 0x3) == 0) {
+            rte_prefetch0(&rx_ring[idx]);
+            rte_prefetch0(&sw_ring[idx]);
+        }
+
+        rxm->pkt_length = rxdp->length;
+        rxm->pkt_type = rxdp->type;
+        rxm->eop = rxdp->eop;
+        rte_prefetch0(&rxm[1]);
+        //DBLOG("UL DESC[%1u][%3u]: virtAddr=0x%lX phyAddr=0x%lX Length=%u Type=%1u EOP=%1u\n",
+        //    queue_id, idx, (uint64_t)&rxm[1], rxdp->phy_addr, rxdp->length, rxdp->type, rxdp->eop);
+        rx_blks[nb_rx++] = rxm;
+
+        sw_ring[idx].mblk = nmb;
+        rxdp->phy_addr = nmb->buf_phy_addr;
+        rxdp->length = 0;
+
+        rx_id++;
+        nb_hold++;
+    }
+
+    rxq->rc_cnt = rx_id;
+    if (nb_hold > rxq->rx_free_thresh) {
+        rte_io_wmb();
+        *rxq->rrccnt_reg_addr = rxq->rc_cnt;
+        nb_hold = 0;
+    }
+    rxq->nb_rx_hold = nb_hold;
+    return nb_rx;
+}
+
+uint16_t pc802_tx_mblk_burst(uint16_t port_id, uint16_t queue_id,
+    PC802_Mem_Block_t **tx_blks, uint16_t nb_blks)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_tx_queue *txq = &adapter->txq[queue_id];
+    struct pc802_tx_entry *sw_ring = txq->sw_ring;
+    struct pc802_tx_entry *txe;
+    volatile PC802_Descriptor_t *tx_ring = txq->tx_ring;
+    volatile PC802_Descriptor_t *txd;
+    PC802_Mem_Block_t     *tx_blk;
+    uint32_t mask = txq->nb_tx_desc - 1;
+    uint32_t idx;
+    uint32_t tx_id = txq->rc_cnt;
+    uint16_t nb_tx;
+
+    if (txq->nb_tx_free < txq->tx_free_thresh) {
+        txq->nb_tx_free = (uint32_t)txq->nb_tx_desc - txq->rc_cnt + *txq->tepcnt_mirror_addr;
+    }
+
+    nb_blks = (txq->nb_tx_free < nb_blks) ? txq->nb_tx_free : nb_blks;
+    for (nb_tx = 0; nb_tx < nb_blks; nb_tx++) {
+        tx_blk = *tx_blks++;
+        idx = tx_id & mask;
+        txe = &sw_ring[idx];
+        txd = &tx_ring[idx];
+
+        if ((txe->mblk) && (txd->type)) {
+            pc802_free_mem_block(txe->mblk);
+        }
+
+        txd->phy_addr = tx_blk->buf_phy_addr;
+        txd->length = tx_blk->pkt_length;
+        txd->type = tx_blk->pkt_type;
+        txd->eop = tx_blk->eop;
+        //DBLOG("DL DESC[%1u][%3u]: virtAddr=0x%lX phyAddr=0x%lX Length=%u Type=%1u EOP=%1u\n",
+        //    queue_id, idx, (uint64_t)&tx_blk[1], txd->phy_addr, txd->length, txd->type, txd->eop);
+        txe->mblk = tx_blk;
+        tx_blk->next =  NULL;
+        tx_id++;
+    }
+
+
+    PMD_TX_LOG(DEBUG, "port_id=%u queue_id=%u tx_tail=%u nb_tx=%u",
+        (unsigned) txq->port_id, (unsigned) txq->queue_id,
+        (unsigned) tx_id, (unsigned) nb_tx);
+    txq->nb_tx_free -= nb_blks;
+    txq->rc_cnt = tx_id;
+    rte_wmb();
+    *txq->trccnt_reg_addr = tx_id;
+
+    return nb_tx;
+}
+
+static int
+eth_pc802_infos_get(struct rte_eth_dev *dev, struct rte_eth_dev_info *dev_info)
+{
+    //struct e1000_hw *hw = E1000_DEV_PRIVATE_TO_HW(dev->data->dev_private);
+    dev = dev;
+
+    dev_info->min_rx_bufsize = 128; /* See BSIZE field of RCTL register. */
+    dev_info->max_rx_pktlen = 1500; //em_get_max_pktlen(dev);
+    dev_info->max_mac_addrs = 1; //hw->mac.rar_entry_count;
+
+    /*
+     * Starting with 631xESB hw supports 2 TX/RX queues per port.
+     * Unfortunatelly, all these nics have just one TX context.
+     * So we have few choises for TX:
+     * - Use just one TX queue.
+     * - Allow cksum offload only for one TX queue.
+     * - Don't allow TX cksum offload at all.
+     * For now, option #1 was chosen.
+     * To use second RX queue we have to use extended RX descriptor
+     * (Multiple Receive Queues are mutually exclusive with UDP
+     * fragmentation and are not supported when a legacy receive
+     * descriptor format is used).
+     * Which means separate RX routinies - as legacy nics (82540, 82545)
+     * don't support extended RXD.
+     * To avoid it we support just one RX queue for now (no RSS).
+     */
+
+    dev_info->max_rx_queues = 1;
+    dev_info->max_tx_queues = 1;
+
+    dev_info->rx_queue_offload_capa = 0;
+    dev_info->rx_offload_capa = 0;
+    dev_info->tx_queue_offload_capa = 0;
+    dev_info->tx_offload_capa = 0;
+
+    dev_info->rx_desc_lim = (struct rte_eth_desc_lim) {
+        .nb_max = MAX_DESC_NUM,
+        .nb_min = 64,
+        .nb_align = 64,
+        .nb_seg_max = 1,
+        .nb_mtu_seg_max = 1,
+    };
+
+    dev_info->tx_desc_lim = (struct rte_eth_desc_lim) {
+        .nb_max = MAX_DESC_NUM,
+        .nb_min = 64,
+        .nb_align = 64,
+        .nb_seg_max = 1,
+        .nb_mtu_seg_max = 1,
+    };
+
+    dev_info->speed_capa = ETH_LINK_SPEED_10M_HD | ETH_LINK_SPEED_10M |
+            ETH_LINK_SPEED_100M_HD | ETH_LINK_SPEED_100M |
+            ETH_LINK_SPEED_1G;
+
+    /* Preferred queue parameters */
+    dev_info->default_rxportconf.nb_queues = 1;
+    dev_info->default_txportconf.nb_queues = 1;
+    dev_info->default_txportconf.ring_size = 256;
+    dev_info->default_rxportconf.ring_size = 256;
+
+    return 0;
+}
+
+static int
+eth_pc802_configure(struct rte_eth_dev *dev)
+{
+
+    PMD_INIT_FUNC_TRACE();
+
+    dev = dev;
+
+    PMD_INIT_FUNC_TRACE();
+
+    return 0;
+}
+
+static void
+pc802_rx_queue_release_mbufs(struct pc802_rx_queue *rxq)
+{
+    unsigned i;
+
+    if (rxq->sw_ring != NULL) {
+        for (i = 0; i != rxq->nb_rx_desc; i++) {
+            if (rxq->sw_ring[i].mbuf != NULL) {
+                rte_pktmbuf_free_seg(rxq->sw_ring[i].mbuf);
+                rxq->sw_ring[i].mbuf = NULL;
+            }
+        }
+    }
+}
+
+static void
+pc802_rx_queue_release(struct pc802_rx_queue *rxq)
+{
+    if (rxq != NULL) {
+        pc802_rx_queue_release_mbufs(rxq);
+        rte_free(rxq->sw_ring);
+    }
+}
+
+/* Reset dynamic em_rx_queue fields back to defaults */
+static void
+pc802_reset_rx_queue(struct pc802_rx_queue *rxq)
+{
+    //rxq->ep_cnt = 0;
+    rxq->nb_rx_hold = 0;
+    //rxq->pkt_first_seg = NULL;
+    //rxq->pkt_last_seg = NULL;
+}
+
+static int
+eth_pc802_rx_queue_setup(struct rte_eth_dev *dev,
+        uint16_t queue_idx,
+        uint16_t nb_desc,
+        unsigned int socket_id,
+        const struct rte_eth_rxconf *rx_conf,
+        struct rte_mempool *mp)
+{
+    struct pc802_rx_queue *rxq;
+
+    struct pc802_adapter *adapter =
+            PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    socket_id = socket_id;
+    rx_conf = rx_conf;
+
+    if (!isPowerOf2(nb_desc))
+            return -(EINVAL);
+
+    /* Free memory prior to re-allocation if needed. */
+    if (dev->data->rx_queues[queue_idx] != NULL) {
+        pc802_rx_queue_release(dev->data->rx_queues[queue_idx]);
+        dev->data->rx_queues[queue_idx] = NULL;
+    }
+
+    rxq = &adapter->rxq[queue_idx];
+
+    /* Allocate software ring. */
+    if ((rxq->sw_ring = rte_zmalloc("rxq->sw_ring",
+            sizeof (rxq->sw_ring[0]) * nb_desc,
+            RTE_CACHE_LINE_SIZE)) == NULL) {
+        pc802_rx_queue_release(rxq);
+        return -ENOMEM;
+    }
+
+    rxq->mb_pool = mp;
+    rxq->nb_rx_desc = nb_desc;
+    rxq->rx_free_thresh = 32; //rx_conf->rx_free_thresh;
+    rxq->queue_id = queue_idx;
+    rxq->port_id = dev->data->port_id;
+
+    rxq->rrccnt_reg_addr = &bar->RRCCNT[queue_idx];
+    rxq->repcnt_mirror_addr = &adapter->pDescs->mr.REPCNT[queue_idx];
+    rxq->rx_ring = adapter->pDescs->ul[queue_idx];
+    //rxq->rx_ring_phys_addr = adapter->descs_phy_addr + get_ul_desc_offset(queue_idx, 0);
+
+    //PMD_INIT_LOG(DEBUG, "sw_ring=%p hw_ring=%p dma_addr=0x%"PRIx64,
+    //       rxq->sw_ring, rxq->rx_ring, rxq->rx_ring_phys_addr);
+
+    dev->data->rx_queues[queue_idx] = rxq;
+    //pc802_reset_rx_queue(rxq);
+    return 0;
+}
+
+static void
+pc802_tx_queue_release_mbufs(struct pc802_tx_queue *txq)
+{
+    unsigned i;
+
+    if (txq->sw_ring != NULL) {
+        for (i = 0; i != txq->nb_tx_desc; i++) {
+            if (txq->sw_ring[i].mbuf != NULL) {
+                rte_pktmbuf_free_seg(txq->sw_ring[i].mbuf);
+                txq->sw_ring[i].mbuf = NULL;
+            }
+        }
+    }
+}
+
+static void
+pc802_tx_queue_release(struct pc802_tx_queue *txq)
+{
+    if (txq != NULL) {
+        pc802_tx_queue_release_mbufs(txq);
+        rte_free(txq->sw_ring);
+    }
+}
+
+/* (Re)set dynamic em_tx_queue fields to defaults */
+static void
+pc802_reset_tx_queue(struct pc802_tx_queue *txq)
+{
+    uint16_t i, nb_desc;
+    static const PC802_Descriptor_t txd_init = {
+        .phy_addr = 0,
+        .length = 0,
+        .eop = 1,
+        .type = 1
+    };
+
+    nb_desc = txq->nb_tx_desc;
+
+    /* Initialize ring entries */
+
+    //prev = (uint16_t) (nb_desc - 1);
+
+    for (i = 0; i < nb_desc; i++) {
+        txq->tx_ring[i] = txd_init;
+        txq->sw_ring[i].mbuf = NULL;
+        //txq->sw_ring[i].last_id = i;
+        //txq->sw_ring[prev].next_id = i;
+        //prev = i;
+    }
+
+    txq->nb_tx_free = nb_desc;
+    //txq->last_desc_cleaned = (uint16_t)(nb_desc - 1);
+    //txq->nb_tx_used = 0;
+    //txq->tx_tail = 0;
+}
+
+static int
+eth_pc802_tx_queue_setup(struct rte_eth_dev *dev,
+        uint16_t queue_idx,
+        uint16_t nb_desc,
+        unsigned int socket_id,
+        const struct rte_eth_txconf *tx_conf)
+{
+    struct pc802_tx_queue *txq;
+    //struct e1000_hw     *hw;
+    //uint32_t tsize;
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+
+    if (!isPowerOf2(nb_desc))
+        return -(EINVAL);
+
+    socket_id = socket_id;
+    tx_conf = tx_conf;
+
+    /* Free memory prior to re-allocation if needed... */
+    if (dev->data->tx_queues[queue_idx] != NULL) {
+        pc802_tx_queue_release(dev->data->tx_queues[queue_idx]);
+        dev->data->tx_queues[queue_idx] = NULL;
+    }
+
+    txq = &adapter->txq[queue_idx];
+
+    /* Allocate software ring */
+    if ((txq->sw_ring = rte_zmalloc("txq->sw_ring",
+            sizeof(txq->sw_ring[0]) * nb_desc,
+            RTE_CACHE_LINE_SIZE)) == NULL) {
+        pc802_tx_queue_release(txq);
+        return -ENOMEM;
+    }
+
+    txq->nb_tx_desc = nb_desc;
+    txq->nb_tx_free = nb_desc;
+    txq->tx_free_thresh = 32;
+    txq->queue_id = queue_idx;
+    txq->port_id = dev->data->port_id;
+
+    //txq->tx_ring_phys_addr = adapter->descs_phy_addr + get_dl_desc_offset(queue_idx, 0);
+    txq->tx_ring = adapter->pDescs->dl[queue_idx];
+    txq->trccnt_reg_addr = (volatile uint32_t *)&bar->TRCCNT[queue_idx];
+    txq->tepcnt_mirror_addr =(volatile uint32_t *)&adapter->pDescs->mr.TEPCNT[queue_idx];
+
+    //PMD_INIT_LOG(DEBUG, "sw_ring=%p hw_ring=%p dma_addr=0x%"PRIx64,
+    //       txq->sw_ring, txq->tx_ring, txq->tx_ring_phys_addr);
+
+    pc802_reset_tx_queue(txq);
+
+    dev->data->tx_queues[queue_idx] = txq;
+    return 0;
+}
+
+static int
+eth_pc802_promiscuous_enable(struct rte_eth_dev *dev)
+{
+    dev = dev;
+    return 0;
+}
+
+static void
+pc802_dev_clear_queues(struct rte_eth_dev *dev)
+{
+    uint16_t i;
+    struct pc802_tx_queue *txq;
+    struct pc802_rx_queue *rxq;
+
+    for (i = 0; i < dev->data->nb_tx_queues; i++) {
+        txq = dev->data->tx_queues[i];
+        if (txq != NULL) {
+            pc802_tx_queue_release_mbufs(txq);
+            pc802_reset_tx_queue(txq);
+        }
+    }
+
+    for (i = 0; i < dev->data->nb_rx_queues; i++) {
+        rxq = dev->data->rx_queues[i];
+        if (rxq != NULL) {
+            pc802_rx_queue_release_mbufs(rxq);
+            pc802_reset_rx_queue(rxq);
+        }
+    }
+}
+
+/**
+ * Interrupt handler which shall be registered at first.
+ *
+ * @param handle
+ *  Pointer to interrupt handle.
+ * @param param
+ *  The address of parameter (struct rte_eth_dev *) regsitered before.
+ *
+ * @return
+ *  void
+ */
+static void
+eth_pc802_interrupt_handler(void *param)
+{
+    struct rte_eth_dev *dev = (struct rte_eth_dev *)param;
+
+    rte_eth_dev_callback_process(dev, RTE_ETH_EVENT_INTR_LSC, NULL);
+}
+
+/*********************************************************************
+ *
+ *  This routine disables all traffic on the adapter by issuing a
+ *  global reset on the MAC.
+ *
+ **********************************************************************/
+static int
+eth_pc802_stop(struct rte_eth_dev *dev)
+{
+    //struct pc802_adapter *adapter =
+    //        PC802_DEV_PRIVATE(dev->data->dev_private);
+    //PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    struct rte_eth_link link;
+    struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(dev);
+    struct rte_intr_handle *intr_handle = &pci_dev->intr_handle;
+
+    pc802_dev_clear_queues(dev);
+
+    /* clear the recorded link status */
+    memset(&link, 0, sizeof(link));
+    rte_eth_linkstatus_set(dev, &link);
+
+    if (!rte_intr_allow_others(intr_handle))
+        /* resume to the default handler */
+        rte_intr_callback_register(intr_handle,
+                       eth_pc802_interrupt_handler,
+                       (void *)dev);
+
+    /* Clean datapath event and queue/vec mapping */
+    rte_intr_efd_disable(intr_handle);
+    if (intr_handle->intr_vec != NULL) {
+        rte_free(intr_handle->intr_vec);
+        intr_handle->intr_vec = NULL;
+    }
+
+    return 0;
+}
+
+/*********************************************************************
+ *
+ *  Enable transmit unit.
+ *
+ **********************************************************************/
+static void
+eth_pc802_tx_init(struct rte_eth_dev *dev)
+{
+    struct pc802_adapter *adapter =
+            PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    struct pc802_tx_queue *txq;
+    uint16_t i;
+
+    /* Setup the Base and Length of the Tx Descriptor Rings. */
+    for (i = 0; i < dev->data->nb_tx_queues; i++) {
+        txq = dev->data->tx_queues[i];
+        PC802_WRITE_REG(bar->TRCCNT[i], 0);
+        PC802_WRITE_REG(bar->TDNUM[i], txq->nb_tx_desc);
+    }
+}
+
+static int
+pc802_alloc_rx_queue_mbufs(struct pc802_rx_queue *rxq)
+{
+    struct pc802_rx_entry *rxe = rxq->sw_ring;
+    uint64_t dma_addr;
+    unsigned i;
+
+    /* Initialize software ring entries */
+    for (i = 0; i < rxq->nb_rx_desc; i++) {
+        volatile PC802_Descriptor_t *rxd;
+        struct rte_mbuf *mbuf = rte_mbuf_raw_alloc(rxq->mb_pool);
+
+        if (mbuf == NULL) {
+            PMD_INIT_LOG(ERR, "RX mbuf alloc failed "
+                     "queue_id=%hu", rxq->queue_id);
+            return -ENOMEM;
+        }
+
+        dma_addr =
+            rte_cpu_to_le_64(rte_mbuf_data_iova_default(mbuf));
+
+        /* Clear HW ring memory */
+        rxd = &rxq->rx_ring[i];
+        rxd->phy_addr = dma_addr;
+        rxd->length = 0;
+        rxe[i].mbuf = mbuf;
+    }
+
+    return 0;
+}
+
+
+/*********************************************************************
+ *
+ *  Enable receive unit.
+ *
+ **********************************************************************/
+static int
+eth_pc802_rx_init(struct rte_eth_dev *dev)
+{
+    struct pc802_adapter *adapter =
+            PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    struct pc802_rx_queue *rxq;
+    //struct rte_eth_rxmode *rxmode;
+    //uint32_t rctl;
+    //uint32_t rfctl;
+    //uint32_t rxcsum;
+    //uint32_t rctl_bsize;
+    uint16_t i;
+    int ret;
+
+
+    //dev->rx_pkt_burst = (eth_rx_burst_t)eth_em_recv_pkts;
+
+    /* Configure and enable each RX queue. */
+    for (i = 0; i < dev->data->nb_rx_queues; i++) {
+        //uint64_t bus_addr;
+        //uint32_t rxdctl;
+
+        rxq = dev->data->rx_queues[i];
+
+        /* Allocate buffers for descriptor rings and setup queue */
+        ret = pc802_alloc_rx_queue_mbufs(rxq);
+        if (ret)
+            return ret;
+
+        rxq->rc_cnt = 0;
+        PC802_WRITE_REG(bar->RDNUM[i], rxq->nb_rx_desc);
+        PC802_WRITE_REG(bar->RRCCNT[i], 0);
+    }
+
+    return 0;
+}
+
+static int
+eth_pc802_start(struct rte_eth_dev *dev)
+{
+    struct pc802_adapter *adapter =
+            PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    //struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(dev);
+    //struct rte_intr_handle *intr_handle = &pci_dev->intr_handle;
+    int ret;
+    //uint32_t intr_vector = 0;
+    //uint32_t *speeds;
+    //int num_speeds;
+    //bool autoneg;
+    int socket_id;
+    const struct rte_memzone *mz;
+
+    PMD_INIT_FUNC_TRACE();
+
+    eth_pc802_stop(dev);
+
+    eth_pc802_tx_init(dev);
+
+    ret = eth_pc802_rx_init(dev);
+    if (ret) {
+        PMD_INIT_LOG(ERR, "Unable to initialize RX hardware");
+        pc802_dev_clear_queues(dev);
+        return ret;
+    }
+
+    adapter->stopped = 0;
+
+    uint32_t haddr = (uint32_t)(adapter->descs_phy_addr >> 32);
+    uint32_t laddr = (uint32_t)adapter->descs_phy_addr;
+    PC802_WRITE_REG(bar->DBAL, laddr);
+    PC802_WRITE_REG(bar->DBAH, haddr);
+    DBLOG("DBA = 0x%08X %08X\n", bar->DBAH, bar->DBAL);
+
+    socket_id = dev->device->numa_node;
+    mz = rte_memzone_reserve_aligned("PC802DBG", ((uint32_t)160 << 20), socket_id, RTE_MEMZONE_IOVA_CONTIG, 0x10000);
+    if (mz == NULL)
+        return -ENOMEM;
+    adapter->dbg_rccnt = 0;
+    adapter->dbg = mz->addr;
+    haddr = (uint32_t)(mz->iova >> 32);
+    laddr = (uint32_t)mz->iova;
+    PC802_WRITE_REG(bar->DBGRCAL, laddr);
+    PC802_WRITE_REG(bar->DBGRCAH, haddr);
+    PC802_WRITE_REG(bar->DBGRCCNT, adapter->dbg_rccnt);
+    DBLOG("DEBUG NPU Memory = 0x%08X %08X\n", bar->DBGRCAH, bar->DBGRCAL);
+
+    volatile uint32_t devRdy;
+
+    usleep(1000);
+    rte_wmb();
+    PC802_WRITE_REG(bar->ULDMAN, 4);
+    DBLOG("Set UL DMA Count = 4\n");
+    PC802_WRITE_REG(bar->DEVEN, 1);
+
+    do {
+        devRdy = PC802_READ_REG(bar->DEVRDY);
+    } while (3 != devRdy);
+    DBLOG("DEVEN = 1, DEVRDY = 3\n");
+
+    volatile uint32_t macAddrL;
+    macAddrL = PC802_READ_REG(bar->MACADDRL);
+    adapter->eth_addr.addr_bytes[4] |= ((macAddrL >> 8) & 0xF);
+    adapter->eth_addr.addr_bytes[5] |= (macAddrL & 0xFF);
+
+    pthread_t tid;
+    pthread_create(&tid, NULL, pc802_process_phy_test_vectors, NULL);
+
+    PMD_INIT_LOG(DEBUG, "<<");
+
+    return 0;
+}
+
+static uint16_t
+eth_pc802_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts,
+        uint16_t nb_pkts)
+{
+    struct pc802_tx_queue *txq;
+    struct pc802_tx_entry *sw_ring;
+    struct pc802_tx_entry *txe;
+    volatile PC802_Descriptor_t *tx_ring;
+    volatile PC802_Descriptor_t *txd;
+    struct rte_mbuf     *tx_pkt;
+    uint32_t mask;
+    uint32_t idx;
+    uint32_t tx_id;
+    uint16_t nb_tx_free;
+    uint16_t nb_tx;
+    uint16_t mb_pkts;
+
+    txq = tx_queue;
+    sw_ring = txq->sw_ring;
+    tx_ring = txq->tx_ring;
+    mask = txq->nb_tx_desc - 1;
+    tx_id   = txq->rc_cnt;
+
+    /* Determine if the descriptor ring needs to be cleaned. */
+     if (txq->nb_tx_free < txq->tx_free_thresh) {
+        txq->nb_tx_free = (uint32_t)txq->nb_tx_desc - txq->rc_cnt + *txq->tepcnt_mirror_addr;
+     }
+
+    nb_tx_free = txq->nb_tx_free;
+    mb_pkts = (nb_tx_free < nb_pkts) ? nb_tx_free : nb_pkts;
+    /* TX loop */
+    for (nb_tx = 0; nb_tx < mb_pkts; nb_tx++) {
+        tx_pkt = *tx_pkts++;
+        idx = tx_id & mask;
+        txe = &sw_ring[idx];
+
+        if (txe->mbuf) {
+            rte_pktmbuf_free_seg(txe->mbuf);
+        }
+        txd = &tx_ring[idx];
+        txd->phy_addr = rte_mbuf_data_iova(tx_pkt);
+        txd->length = tx_pkt->data_len;
+        txq->stats.bytes += tx_pkt->data_len;
+        txd->eop = (tx_pkt->next == NULL);
+        txd->type = tx_pkt->packet_type;
+        txe->mbuf = tx_pkt;
+        tx_id++;
+    }
+    nb_tx_free -= mb_pkts;
+
+    /*
+     * Set the Transmit Descriptor Tail (TDT)
+     */
+    PMD_TX_LOG(DEBUG, "port_id=%u queue_id=%u tx_tail=%u nb_tx=%u",
+        (unsigned) txq->port_id, (unsigned) txq->queue_id,
+        (unsigned) tx_id, (unsigned) nb_tx);
+    txq->nb_tx_free = nb_tx_free;
+    txq->rc_cnt = tx_id;
+    rte_wmb();
+    *txq->trccnt_reg_addr = tx_id;
+    txq->stats.pkts += mb_pkts;
+    txq->stats.err_pkts += nb_pkts -  mb_pkts;
+
+    return nb_tx;
+}
+
+static uint16_t
+eth_pc802_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
+        uint16_t nb_pkts)
+{
+    struct pc802_rx_queue *rxq;
+    volatile PC802_Descriptor_t *rx_ring;
+    volatile PC802_Descriptor_t *rxdp;
+    struct pc802_rx_entry *sw_ring;
+    struct rte_mbuf *rxm;
+    struct rte_mbuf *nmb;
+    uint32_t mask;
+    uint32_t idx;
+    uint32_t rx_id;
+    uint32_t ep_txed;
+    uint16_t pkt_len;
+    uint16_t nb_rx;
+    uint16_t nb_hold;
+    uint16_t mb_pkts;
+
+    rxq = rx_queue;
+    mask = rxq->nb_rx_desc - 1;
+
+    nb_rx = 0;
+    nb_hold = rxq->nb_rx_hold;
+    rx_id = rxq->rc_cnt;
+    rx_ring = rxq->rx_ring;
+    sw_ring = rxq->sw_ring;
+    ep_txed = *rxq->repcnt_mirror_addr - rx_id;
+    mb_pkts = (ep_txed < nb_pkts) ? ep_txed : nb_pkts;
+    while (nb_rx < mb_pkts) {
+        idx = rx_id & mask;
+        rxdp = &rx_ring[idx];
+
+        nmb = rte_mbuf_raw_alloc(rxq->mb_pool);
+        if (nmb == NULL) {
+            PMD_RX_LOG(DEBUG, "RX mbuf alloc failed port_id=%u "
+                   "queue_id=%u",
+                   (unsigned) rxq->port_id,
+                   (unsigned) rxq->queue_id);
+            rte_eth_devices[rxq->port_id].data->rx_mbuf_alloc_failed++;
+            break;
+        }
+
+        /* Prefetch next mbuf while processing current one. */
+        rte_prefetch0(sw_ring[idx].mbuf);
+
+        /*
+         * When next RX descriptor is on a cache-line boundary,
+         * prefetch the next 4 RX descriptors and the next 8 pointers
+         * to mbufs.
+         */
+        if ((idx & 0x3) == 0) {
+            rte_prefetch0(&rx_ring[idx]);
+            rte_prefetch0(&sw_ring[idx]);
+        }
+
+        rxm = sw_ring[idx].mbuf;
+        pkt_len = (uint16_t)rte_le_to_cpu_16(rxdp->length);
+        rxm->data_off = RTE_PKTMBUF_HEADROOM;
+        rte_prefetch0((char *)rxm->buf_addr + rxm->data_off);
+        rxm->nb_segs = 1;
+        rxm->next = NULL;
+        rxm->pkt_len = pkt_len;
+        rxm->data_len = pkt_len;
+        rxq->stats.bytes += pkt_len;
+        rxm->packet_type = rxdp->type;
+        rxm->port = rxq->port_id;
+
+        rxm->ol_flags = 0;
+        rx_pkts[nb_rx++] = rxm;
+
+        sw_ring[idx].mbuf = nmb;
+        rxdp->phy_addr = rte_cpu_to_le_64(rte_mbuf_data_iova_default(nmb));
+        rxdp->length = 0;
+        rxdp->eop = 1;
+        rxdp->type = 1;
+
+        rx_id++;
+        nb_hold++;
+    }
+
+    rxq->rc_cnt = rx_id;
+    if (nb_hold > rxq->rx_free_thresh) {
+        rte_io_wmb();
+        *rxq->rrccnt_reg_addr = rxq->rc_cnt;
+        nb_hold = 0;
+    }
+    rxq->nb_rx_hold = nb_hold;
+    rxq->stats.pkts += nb_rx;
+    rxq->stats.err_pkts += nb_pkts - nb_rx;
+    return nb_rx;
+}
+
+static void
+eth_pc802_queue_release(void *q __rte_unused)
+{
+}
+
+static int
+eth_pc802_link_update(struct rte_eth_dev *dev __rte_unused,
+        int wait_to_complete __rte_unused)
+{
+    return 0;
+}
+
+static int
+eth_pc802_stats_get(struct rte_eth_dev *dev, struct rte_eth_stats *stats)
+{
+    unsigned long rx_packets_total = 0, rx_bytes_total = 0;
+    unsigned long tx_packets_total = 0, tx_bytes_total = 0;
+    struct rte_eth_dev_data *data = dev->data;
+    unsigned long tx_packets_err_total = 0;
+    unsigned int i, num_stats;
+    struct pc802_rx_queue *rxq;
+    struct pc802_tx_queue *txq;
+
+    num_stats = RTE_MIN((unsigned int)RTE_ETHDEV_QUEUE_STAT_CNTRS,
+            data->nb_rx_queues);
+    for (i = 0; i < num_stats; i++) {
+        rxq = data->rx_queues[i];
+        stats->q_ipackets[i] = rxq->stats.pkts;
+        stats->q_ibytes[i] = rxq->stats.bytes;
+        rx_packets_total += stats->q_ipackets[i];
+        rx_bytes_total += stats->q_ibytes[i];
+    }
+
+    num_stats = RTE_MIN((unsigned int)RTE_ETHDEV_QUEUE_STAT_CNTRS,
+            data->nb_tx_queues);
+    for (i = 0; i < num_stats; i++) {
+        txq = data->tx_queues[i];
+        stats->q_opackets[i] = txq->stats.pkts;
+        stats->q_obytes[i] = txq->stats.bytes;
+        stats->q_errors[i] = txq->stats.err_pkts;
+        tx_packets_total += stats->q_opackets[i];
+        tx_bytes_total += stats->q_obytes[i];
+        tx_packets_err_total += stats->q_errors[i];
+    }
+
+    stats->ipackets = rx_packets_total;
+    stats->ibytes = rx_bytes_total;
+    stats->opackets = tx_packets_total;
+    stats->obytes = tx_bytes_total;
+    stats->oerrors = tx_packets_err_total;
+
+    return 0;
+}
+
+static int
+eth_pc802_stats_reset(struct rte_eth_dev *dev)
+{
+    struct rte_eth_dev_data *data = dev->data;
+    struct pc802_rx_queue *rxq;
+    struct pc802_tx_queue *txq;
+    unsigned int i;
+
+    for (i = 0; i < data->nb_rx_queues; i++) {
+        rxq = data->rx_queues[i];
+        rxq->stats.pkts = 0;
+        rxq->stats.bytes = 0;
+        rxq->stats.err_pkts = 0;
+    }
+    for (i = 0; i < data->nb_tx_queues; i++) {
+        txq = data->tx_queues[i];
+        txq->stats.pkts = 0;
+        txq->stats.bytes = 0;
+        txq->stats.err_pkts = 0;
+    }
+    return 0;
+}
+
+uint64_t *pc802_get_debug_mem(uint16_t port_id)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    return adapter->dbg;
+}
+
+void pc802_access_ep_mem(uint16_t port_id, uint32_t startAddr, uint32_t bytesNum, uint32_t cmd)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    PC802_BAR_t *bar = (PC802_BAR_t *)adapter->bar0_addr;
+    uint32_t epcnt;
+
+    PC802_WRITE_REG(bar->DBGEPADDR, startAddr);
+    PC802_WRITE_REG(bar->DBGBYTESNUM, bytesNum);
+    PC802_WRITE_REG(bar->DBGCMD, cmd);
+    adapter->dbg_rccnt++;
+    PC802_WRITE_REG(bar->DBGRCCNT, adapter->dbg_rccnt);
+
+    do {
+        usleep(10);
+        epcnt = PC802_READ_REG(bar->DBGEPCNT);
+    } while(epcnt != adapter->dbg_rccnt);
+    return;
+}
+
+void pc802_show_pcie_counter(uint16_t port_id)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    uint16_t queue_id;
+    struct pc802_tx_queue *txq;
+    struct pc802_rx_queue *rxq;
+    static const char *qname[] = {"Ethernet  ", "EMBB_Data ", "EMBB_Ctrl "};
+    for (queue_id = 0; queue_id <= PC802_TRAFFIC_5G_EMBB_CTRL; queue_id++) {
+        txq = &adapter->txq[queue_id];
+        rxq = &adapter->rxq[queue_id];
+        printf("DL %s: RC = %3u   EP = %3u\n", qname[queue_id],
+            *txq->trccnt_reg_addr, *txq->tepcnt_mirror_addr);
+        printf("UL %s: RC = %3u   EP = %3u    RC_HOLD = %3u\n", qname[queue_id],
+            *rxq->rrccnt_reg_addr, *rxq->repcnt_mirror_addr, rxq->nb_rx_hold);
+    }
+}
+
+void pc802_show_tx_info(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_tx_queue *txq = &adapter->txq[queue_id];
+    volatile PC802_Descriptor_t *txd;
+    PC802_Mem_Block_t     *tx_blk;
+    rc_counter &= (txq->nb_tx_desc - 1);
+    txd = &txq->tx_ring[rc_counter];
+    tx_blk = txq->sw_ring[rc_counter].mblk;
+    printf("DL_Desc[%1u][%1u][%3u]: phyAddr=0x%lX Len=%6u Type=%2u EOP=%1u\n",
+        port_id, queue_id, rc_counter, txd->phy_addr, txd->length, txd->type, txd->eop);
+    printf("DL_Buf: virtAddr=%p phyAddr=0x%lX, Len=%6u Type=%2u EOP=%1u\n",
+        &tx_blk[1], tx_blk->buf_phy_addr, tx_blk->pkt_length, tx_blk->pkt_type, tx_blk->eop);
+    uint8_t *p = (uint8_t *)&tx_blk[1];
+    uint32_t L, C;
+    for (L = 0; L < 4; L++) {
+        printf("DL_Data[%1u]: ", L);
+        for (C = 0; C < 16; C++) {
+            printf("%02X ", *p++);
+        }
+        printf("\n");
+    }
+}
+
+void pc802_show_rx_info(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_rx_queue *rxq = &adapter->rxq[queue_id];
+    volatile PC802_Descriptor_t *rxd;
+    PC802_Mem_Block_t     *rx_blk;
+    rc_counter &= (rxq->nb_rx_desc - 1);
+    rxd = &rxq->rx_ring[rc_counter];
+    rx_blk = rxq->sw_ring[rc_counter].mblk;
+    printf("UL_Desc[%1u][%1u][%3u]: phyAddr=0x%lX Len=%6u Type=%2u EOP=%1u\n",
+        port_id, queue_id, rc_counter, rxd->phy_addr, rxd->length, rxd->type, rxd->eop);
+    printf("UL_Buf: virtAddr=%p phyAddr=0x%lX, Len=%6u Type=%2u EOP=%1u\n",
+        &rx_blk[1], rx_blk->buf_phy_addr, rx_blk->pkt_length, rx_blk->pkt_type, rx_blk->eop);
+    uint8_t *p = (uint8_t *)&rx_blk[1];
+    uint32_t L, C;
+    for (L = 0; L < 4; L++) {
+        printf("UL_Data[%1u]: ", L);
+        for (C = 0; C < 16; C++) {
+            printf("%02X ", *p++);
+        }
+        printf("\n");
+    }
+}
+
+void pc802_show_tx_data(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_tx_queue *txq = &adapter->txq[queue_id];
+    volatile PC802_Descriptor_t *txd;
+    PC802_Mem_Block_t     *tx_blk;
+    rc_counter &= (txq->nb_tx_desc - 1);
+    txd = &txq->tx_ring[rc_counter];
+    tx_blk = txq->sw_ring[rc_counter].mblk;
+    printf("DL_Desc[%1u][%1u][%3u]: phyAddr=0x%lX Len=%6u Type=%2u EOP=%1u\n",
+        port_id, queue_id, rc_counter, txd->phy_addr, txd->length, txd->type, txd->eop);
+    printf("DL_Buf: virtAddr=%p phyAddr=0x%lX, Len=%6u Type=%2u EOP=%1u\n",
+        &tx_blk[1], tx_blk->buf_phy_addr, tx_blk->pkt_length, tx_blk->pkt_type, tx_blk->eop);
+    uint8_t *p = (uint8_t *)&tx_blk[1];
+    uint32_t LL = (tx_blk->pkt_length + 15) >> 4;
+    uint32_t L, C;
+    for (L = 0; L < LL; L++) {
+        printf("DL_Data[%4u]: ", L);
+        for (C = 0; C < 16; C++) {
+            printf("%02X ", *p++);
+        }
+        printf("\n");
+    }
+}
+
+void pc802_show_rx_data(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter)
+{
+    struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(dev->data->dev_private);
+    struct pc802_rx_queue *rxq = &adapter->rxq[queue_id];
+    volatile PC802_Descriptor_t *rxd;
+    PC802_Mem_Block_t     *rx_blk;
+    rc_counter &= (rxq->nb_rx_desc - 1);
+    rxd = &rxq->rx_ring[rc_counter];
+    rx_blk = rxq->sw_ring[rc_counter].mblk;
+    printf("UL_Desc[%1u][%1u][%3u]: phyAddr=0x%lX Len=%6u Type=%2u EOP=%1u\n",
+        port_id, queue_id, rc_counter, rxd->phy_addr, rxd->length, rxd->type, rxd->eop);
+    printf("UL_Buf: virtAddr=%p phyAddr=0x%lX, Len=%6u Type=%2u EOP=%1u\n",
+        &rx_blk[1], rx_blk->buf_phy_addr, rx_blk->pkt_length, rx_blk->pkt_type, rx_blk->eop);
+    uint8_t *p = (uint8_t *)&rx_blk[1];
+    uint32_t LL = (rx_blk->pkt_length + 15) >> 4;
+    uint32_t L, C;
+    for (L = 0; L < LL; L++) {
+        printf("UL_Data[%4u]: ", L);
+        for (C = 0; C < 16; C++) {
+            printf("%02X ", *p++);
+        }
+        printf("\n");
+    }
+}
+
+
+static const struct eth_dev_ops eth_pc802_ops = {
+    .dev_configure        = eth_pc802_configure,
+    .dev_start            = eth_pc802_start,
+    .dev_stop             = eth_pc802_stop,
+    .promiscuous_enable   = eth_pc802_promiscuous_enable,
+    .dev_infos_get        = eth_pc802_infos_get,
+    .rx_queue_setup       = eth_pc802_rx_queue_setup,
+    .tx_queue_setup       = eth_pc802_tx_queue_setup,
+    .rx_queue_release     = eth_pc802_queue_release,
+    .tx_queue_release     = eth_pc802_queue_release,
+    .link_update          = eth_pc802_link_update,
+    .stats_get            = eth_pc802_stats_get,
+    .stats_reset          = eth_pc802_stats_reset
+};
+
+static const struct rte_eth_link pmd_link = {
+        .link_speed = ETH_SPEED_NUM_10G,
+        .link_duplex = ETH_LINK_FULL_DUPLEX,
+        .link_status = ETH_LINK_DOWN,
+        .link_autoneg = ETH_LINK_FIXED,
+};
+
+static int
+eth_pc802_dev_init(struct rte_eth_dev *eth_dev)
+{
+    struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(eth_dev);
+    struct rte_eth_dev_data *data = eth_dev->data;
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(eth_dev->data->dev_private);
+    PC802_BAR_t *bar;
+
+    data = eth_dev->data;
+    data->nb_rx_queues = 1;
+    data->nb_tx_queues = 1;
+    data->dev_link = pmd_link;
+    data->mac_addrs = &adapter->eth_addr;
+
+    adapter->eth_addr.addr_bytes[0] = 0x8C;
+    adapter->eth_addr.addr_bytes[1] = 0x1F;
+    adapter->eth_addr.addr_bytes[2] = 0x64;
+    adapter->eth_addr.addr_bytes[3] = 0xB4;
+    adapter->eth_addr.addr_bytes[4] = 0xC0;
+    adapter->eth_addr.addr_bytes[5] = 0x00;
+
+    eth_dev->dev_ops = &eth_pc802_ops;
+    eth_dev->rx_pkt_burst = (eth_rx_burst_t)&eth_pc802_recv_pkts;
+    eth_dev->tx_pkt_burst = (eth_tx_burst_t)&eth_pc802_xmit_pkts;
+
+    rte_eth_copy_pci_info(eth_dev, pci_dev);
+
+    adapter->bar0_addr = (uint8_t *)pci_dev->mem_resource[0].addr;
+    gbar = bar = (PC802_BAR_t *)adapter->bar0_addr;
+
+    const struct rte_memzone *mz;
+    uint32_t tsize = sizeof(PC802_Descs_t);
+    mz = rte_memzone_reserve_aligned("PC802_DESCS_MR", tsize, eth_dev->data->numa_node,
+            RTE_MEMZONE_IOVA_CONTIG, 0x10000);
+    if (mz == NULL)
+        return -ENOMEM;
+    memset(mz->addr, 0, tsize);
+    adapter->pDescs = (PC802_Descs_t *)mz->addr;
+    adapter->descs_phy_addr = mz->iova;
+    DBLOG("descs_phy_addr  = 0x%lX\n", adapter->descs_phy_addr);
+    DBLOG("descs_virt_addr = %p\n", adapter->pDescs);
+
+    PC802_WRITE_REG(bar->DEVEN, 0);
+    usleep(1000);
+
+    volatile uint32_t BOOTEPCNT;
+    volatile uint32_t devRdy;
+    BOOTEPCNT = PC802_READ_REG(bar->BOOTEPCNT);
+    DBLOG("BOOTEPCNT = 0x%08X\n", BOOTEPCNT);
+    if (0xFFFFFFFF == BOOTEPCNT) {
+	DBLOG("Wait for DEVRDY = 2 !\n");
+        do {
+            devRdy = PC802_READ_REG(bar->DEVRDY);
+        } while (2 != devRdy);
+        DBLOG("PC802 bootworker has done: DEVEN = 0, DEVRDY = 2\n");
+        return 0;
+    }
+
+    DBLOG("Wait for DEVRDY = 1 !\n");
+    do {
+        devRdy = PC802_READ_REG(bar->DEVRDY);
+    } while (1 != devRdy);
+    DBLOG("DEVEN = 0, DEVRDY = 1\n");
+
+    adapter->started = 1;
+
+    PMD_INIT_LOG(DEBUG, "port_id %d vendorID=0x%x deviceID=0x%x",
+             eth_dev->data->port_id, pci_dev->id.vendor_id,
+             pci_dev->id.device_id);
+
+    pc802_download_boot_image(data->port_id);
+
+    bar->BOOTRCCNT = 0xFFFFFFFF;
+    DBLOG("Wait for DEVRDY = 2 !\n");
+    do {
+        devRdy = PC802_READ_REG(bar->DEVRDY);
+    } while (2 != devRdy);
+    DBLOG("DEVEN = 0, DEVRDY = 2\n");
+
+    return 0;
+}
+
+static int
+eth_pc802_dev_uninit(struct rte_eth_dev *eth_dev)
+{
+    //struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(eth_dev);
+    struct pc802_adapter *adapter =
+        PC802_DEV_PRIVATE(eth_dev->data->dev_private);
+
+    PMD_INIT_FUNC_TRACE();
+
+    if (rte_eal_process_type() != RTE_PROC_PRIMARY)
+        return -EPERM;
+
+    adapter->started = 0;
+
+    return 0;
+}
+
+static int eth_pc802_pci_probe(struct rte_pci_driver *pci_drv __rte_unused,
+    struct rte_pci_device *pci_dev)
+{
+    return rte_eth_dev_pci_generic_probe(pci_dev,
+        sizeof(struct pc802_adapter), eth_pc802_dev_init);
+}
+
+static int eth_pc802_pci_remove(struct rte_pci_device *pci_dev)
+{
+    return rte_eth_dev_pci_generic_remove(pci_dev, eth_pc802_dev_uninit);
+}
+
+static struct rte_pci_driver rte_pc802_pmd = {
+    .id_table = pci_id_pc802_map,
+    .drv_flags = RTE_PCI_DRV_NEED_MAPPING | RTE_PCI_DRV_INTR_LSC,
+    .probe = eth_pc802_pci_probe,
+    .remove = eth_pc802_pci_remove,
+};
+
+RTE_PMD_REGISTER_PCI(net_pc802, rte_pc802_pmd);
+RTE_PMD_REGISTER_PCI_TABLE(net_pc802, pci_id_pc802_map);
+RTE_PMD_REGISTER_KMOD_DEP(net_pc802, "* igb_uio | uio_pci_generic | vfio-pci");
+
+/* see e1000_logs.c */
+RTE_INIT(picocom_pc802_init_log)
+{
+    pc802_init_log();
+}
+
+char * picocom_pc802_version(void)
+{
+    static char ver[256];
+    snprintf(ver, sizeof(ver), "PC802 Driver on NPU side built AT %s ON %s\n", __TIME__, __DATE__);
+    return ver;
+}
+
+__attribute__((__weak__))
+int pc802_download_boot_image(uint16_t port)
+{
+    PC802_BAR_t *bar = pc802_get_BAR(port);
+    volatile uint32_t *BOOTRCCNT = &bar->BOOTRCCNT;
+    volatile uint32_t *BOOTEPCNT = &bar->BOOTEPCNT;
+
+    printf("Begin WEAK pc802_download_boot_image,  port = %hu\n", port);
+    if (0xFFFFFFFF == *BOOTRCCNT) {
+        printf("PC802 ELF image has already been downloaded and is running !\n");
+        return 0;
+    }
+    printf("Begin test_boot_download !\n");
+    *BOOTRCCNT = 0;
+    const struct rte_memzone *mz;
+    uint32_t tsize = 64 * 1024;
+    int socket_id = pc802_get_socket_id(port);
+    mz = rte_memzone_reserve_aligned("PC802_BOOT", tsize, socket_id,
+            RTE_MEMZONE_IOVA_CONTIG, 0x10000);
+
+    uint8_t *pimg = (uint8_t *)mz->addr;
+
+    FILE *fp = fopen("PC802.img", "rb");
+    if (NULL==fp) {
+        DBLOG("Failed to open PC802.img .\n");
+        return -1;
+    }
+
+    bar->BOOTSRCL = (uint32_t)(mz->iova);
+    bar->BOOTSRCH = (uint32_t)(mz->iova >> 32);
+    bar->BOOTDST  = 0;
+    bar->BOOTSZ = 0;
+    uint32_t N;
+    do {
+        N = fread(pimg, 1, tsize, fp);
+        if (N < 4)
+            break;
+        rte_wmb();
+        (*BOOTRCCNT)++;
+        while(*BOOTRCCNT != *BOOTEPCNT)
+            usleep(1);
+        printf("BAR->BOOTRCCNT = %u  Finish downloading %u bytes\n", bar->BOOTRCCNT, N);
+        N = 0;
+    } while (1);
+
+    rte_memzone_free(mz);
+    fclose(fp);
+
+    printf("Finish WEAK test_boot_download !\n");
+    return 0;
+}
+
+int pc802_set_ul_dma_count(uint16_t port, uint32_t n)
+{
+    PC802_BAR_t *bar = pc802_get_BAR(port);
+    if (0 == n)
+        n = 1;
+    if (n > 4)
+        n = 4;
+    bar->ULDMAN = n;
+    rte_wmb();
+    return 0;
+}
+
+int pc802_check_dma_timeout(uint16_t port)
+{
+    static uint32_t timeout_counter[16];
+    static const char *head[] = {"PC802 UL Timeout FINISHED:", "PC802 UL Timeout ERROR:",
+        "PC802 DL Timeout FINISHED:", "PC802 DL Timeout ERROR:"};
+    uint32_t *local_counter;
+    uint32_t *bar_counter;
+    char buf[1024];
+    char *p;
+    int flag;
+    int m, n;
+
+    flag= 0;
+    p = buf;
+    local_counter = &timeout_counter[0];
+    PC802_BAR_t *bar = pc802_get_BAR(port);
+    bar_counter = &bar->ULDMA_TIMEOUT_FINISHED[0];
+    for (m = 0; m < 4; m++) {
+        flag = 0;
+        for (n = 0; n < 4; n++) {
+            if (local_counter[0] != bar_counter[0]) {
+                local_counter[0] = bar_counter[0];
+                if (0 == flag) {
+                    p += sprintf(p, "%s", head[m]);
+                    flag = 1;
+                }
+                p += sprintf(p, " [%1d]=%10u", n, bar_counter[0]);
+            }
+            local_counter++;
+            bar_counter++;
+        }
+        if (flag)
+            p += sprintf(p, "\n");
+    }
+    if (p != buf)
+        printf("%s", buf);
+    return 0;
+}
+
+#define PC802_BAR_EXT_OFFSET  (6 * 1024)
+
+static PC802_BAR_Ext_t * pc802_get_BAR_Ext(uint16_t port)
+{
+    PC802_BAR_t *bar = pc802_get_BAR(port);
+    uint8_t *pu8 = ((uint8_t *)bar) + PC802_BAR_EXT_OFFSET;
+    PC802_BAR_Ext_t *ext = (PC802_BAR_Ext_t *)pu8;
+    return ext;
+}
+
+static void * pc802_process_phy_test_vectors(void *data)
+{
+    data = data;
+    PC802_BAR_Ext_t *ext = pc802_get_BAR_Ext(0);
+    volatile uint32_t MB_EPCNT;
+    uint32_t re = 1;
+
+    while (1) {
+        MB_EPCNT = ext->MB_EPCNT;
+        if (MB_EPCNT == ext->MB_RCCNT) {
+            usleep(10);
+            continue;
+        }
+        if (ext->MB_COMMAND == 12) {
+            re = handle_vec_read(ext->MB_ARGS[0], ext->MB_ARGS[1], ext->MB_ARGS[2], ext->MB_ARGS[3]);
+        } else if (ext->MB_COMMAND == 13) {
+            re = handle_vec_dump(ext->MB_ARGS[0], ext->MB_ARGS[1], ext->MB_ARGS[2]);
+        }
+        ext->MB_RESULT = (0 == re);
+        rte_wmb();
+        ext->MB_RCCNT++;
+    }
+    return NULL;
+}
+
+static uint32_t handle_vec_read(uint32_t file_id, uint32_t offset, uint32_t address, uint32_t length)
+{
+    unsigned int end = offset + length;
+    if ((offset & 3) | (length & 3) | (address & 3)) {
+        DBLOG("ERROR: VEC_READ address, offset and length must be word aligned!\n");
+        return -1;
+    }
+
+    // Look for the testcase directory
+    char * tc_dir = getenv("PC802_TEST_VECTOR_DIR");
+    if (tc_dir == NULL) {
+        DBLOG("ERROR: PC802_TEST_VECTOR_DIR was not defined\n");
+        return -2;
+    }
+
+    // Check if the test vector file exists
+    char file_name[2048];
+    sprintf(file_name, "%s/%u.txt", tc_dir, file_id);
+    if (access(file_name, F_OK) != 0) {
+        DBLOG("ERROR: Failed to open test vector file %s\n", file_name);
+        return -3;
+    }
+
+    // Parse the file
+    DBLOG("Reading vector file %s\n", file_name);
+    unsigned int   data       = 0;
+    unsigned int   vec_cnt = 0;
+    unsigned int   line = 0;
+    FILE         * fh_vector  = fopen(file_name, "r");
+    char           buffer[2048];
+
+    uint32_t *pd = (uint32_t *)pc802_get_debug_mem(0);
+
+    while (fgets(buffer, sizeof(buffer), fh_vector) != NULL) {
+        // Trim trailing newlines
+        buffer[strcspn(buffer, "\r\n")] = 0;
+        if (sscanf(buffer, "%x", &data) == 1) {
+            // In scope
+            if (vec_cnt >= offset && vec_cnt < end) {
+                *pd++ = data;
+            }
+            vec_cnt += 4;
+        } else if (buffer[0] != '#' && strlen(buffer) > 0) { // Allow for comment character '#'
+            DBLOG("ERROR: Unexpected entry parsing line %u of %s: %s", line, file_name, buffer);
+            return -4;
+        }
+        // already done
+        if (vec_cnt >= end) {
+            break;
+        }
+        // Increment line count
+        line++;
+    }
+    pc802_access_ep_mem(0, address, length, DIR_PCIE_DMA_DOWNLINK);
+
+    fclose(fh_vector);
+
+    if (vec_cnt < end) {
+        DBLOG("ERROR: EOF! of %s", file_name);
+        return -5;
+    }
+
+    DBLOG("Loaded a total of %u bytes from %s\n", length, file_name);
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+// handle_vec_dump: Handle task vector dump requests
+// -----------------------------------------------------------------------------
+static uint32_t handle_vec_dump(uint32_t file_id, uint32_t address, uint32_t length)
+{
+    unsigned int offset;
+    if ((length & 3) | (address & 3)) {
+       DBLOG("ERROR: VEC_DUMP address and length must be word aligned!\n");
+       return -1;
+    }
+
+    // Look for the testcase directory
+    char * tc_dir = getenv("PC802_VECTOR_DUMP_DIR");
+    if (tc_dir == NULL) {
+        DBLOG("ERROR: PC802_VECTOR_DUMP_DIR was not defined\n");
+        return -2;
+    }
+
+    // Check if the golden vector file exists
+    char file_name[2048];
+    sprintf(file_name, "%s/%u.txt", tc_dir, file_id);
+    if (access(tc_dir, F_OK) != 0) {
+        DBLOG("ERROR: Failed to open dump dir %s\n", tc_dir);
+        return -3;
+    }
+
+    uint32_t *pd = (uint32_t *)pc802_get_debug_mem(0);
+    pc802_access_ep_mem(0, address, length, DIR_PCIE_DMA_UPLINK);
+
+    // Parse the file
+    DBLOG("Dumping to file %s\n", file_name);
+    FILE         * fh_vector  = fopen(file_name, "w");
+
+    fprintf(fh_vector, "#@%08x, length=%d\n", address, length);
+    for (offset = 0; offset < length; offset += 4) {
+      unsigned int mem_data = *pd++;;
+      fprintf(fh_vector, "%08x\n", mem_data);
+    }
+
+    fclose(fh_vector);
+
+    // Print a success message
+    DBLOG("Dumped %u bytes at address 0x%08x to file %s.\n",
+        length, address, file_name);
+
+    return 0;
+}
+
+uint32_t pc802_vec_read(uint32_t file_id, uint32_t offset, uint32_t address, uint32_t length)
+{
+    return handle_vec_read(file_id, offset, address, length);
+}
+
+uint32_t pc802_vec_dump(uint32_t file_id, uint32_t address, uint32_t length)
+{
+    return handle_vec_dump(file_id, address, length);
+}
+
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pc802_ethdev.h npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_ethdev.h
--- dpdk-21.08/drivers/net/pc802/pc802_ethdev.h	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_ethdev.h	2022-01-21 11:52:16.355570204 +0800
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018-2020 Picocom Corporation
+ */
+#ifndef _PC802_ETHDEV_H_
+#define _PC802_ETHDEV_H_
+
+#include <stdint.h>
+
+#include "pc802_common.h"
+
+static inline void pc802_write_reg(volatile uint32_t *addr, uint32_t value)
+{
+    __asm__ volatile ("" : : : "memory");
+    *addr = value;
+    return;
+}
+
+static inline uint32_t pc802_read_reg(volatile uint32_t *addr)
+{
+    uint32_t val;
+    val = *addr;
+    __asm__ volatile ("" : : : "memory");
+    return val;
+}
+
+#define PC802_WRITE_REG(reg, value) \
+    pc802_write_reg((volatile uint32_t *)&(reg), (value))
+
+struct pc802_mem_block {
+    struct pc802_mem_block *next;
+    struct pc802_mem_block **first;
+    uint32_t alloced;
+    uint64_t buf_phy_addr;
+    uint32_t pkt_length;
+    uint8_t  pkt_type;
+    uint8_t  eop;
+} __attribute__((__aligned__(NPU_CACHE_LINE_SZ)));
+typedef struct pc802_mem_block PC802_Mem_Block_t;
+
+#define PC802_READ_REG(reg) \
+    pc802_read_reg((volatile uint32_t *)&(reg))
+
+PC802_BAR_t * pc802_get_BAR(uint16_t port_id);
+
+int pc802_get_socket_id(uint16_t port_id);
+
+char * picocom_pc802_version(void);
+
+/**
+* @brief Create control queues for Rx
+*
+* @param[in] port_id PC802 chip number,   start with 0
+* @param[in] queue_id Queue Number for non-ethernet traffic, start with 1
+* @param[in] block_size memory block size in byte (buffer header + message body)
+* @param[in] block_num number of memory blocks in the pool of the queue
+* @param[in] nb_desc number of message descriptors, should be less than block_num
+* @return returns 0 if open success, or else return error
+*/
+int pc802_create_rx_queue(uint16_t port_id, uint16_t queue_id, uint32_t block_size, uint32_t block_num, uint16_t nb_desc);
+
+/**
+* @brief Create control queues for Tx
+*
+* @param[in] port_id PC802 chip number,   start with 0
+* @param[in] queue_id Queue Number for non-ethernet traffic, start with 1
+* @param[in] block_size memory block size in byte (buffer header + message body)
+* @param[in] block_num number of memory blocks in the pool of the queue
+* @param[in] nb_desc number of message descriptors, should be less than block_num
+* @return returns 0 if open success, or else return error
+*/
+int pc802_create_tx_queue(uint16_t port_id, uint16_t queue_id, uint32_t block_size, uint32_t block_num, uint16_t nb_desc);
+
+/**
+* @brief Allocated one message memory from current block in used for tx.
+*
+* @param[in] port_id PC802 chip number,start with 0
+* @param[in] queue_id Queue Number for non-ethernet traffic, start with 1
+* @return return pointer to message body, Null when failure
+*/
+PC802_Mem_Block_t * pc802_alloc_tx_mem_block(uint16_t port_id, uint16_t queue_id);
+void pc802_free_mem_block(PC802_Mem_Block_t *mblk);
+
+/**
+* @brief Allocated one message memory from current block in used for rx.
+*
+* @param[in] port_id PC802 chip number,start with 0
+* @param[in] queue_id Queue Number for non-ethernet traffic, start with 1
+* @param[in] rx_blks input+output, pointers to message body
+* @param[in] nb_blks input, maximum number of messages
+* @return return received message numbers
+*/
+uint16_t pc802_rx_mblk_burst(uint16_t port_id, uint16_t queue_id,
+    PC802_Mem_Block_t **rx_blks, uint16_t nb_blks);
+uint16_t pc802_tx_mblk_burst(uint16_t port_id, uint16_t queue_id,
+    PC802_Mem_Block_t **tx_blks, uint16_t nb_blks);
+
+uint64_t *pc802_get_debug_mem(uint16_t port_id);
+void pc802_access_ep_mem(uint16_t port_id, uint32_t startAddr, uint32_t bytesNum, uint32_t cmd);
+void pc802_show_pcie_counter(uint16_t port_id);
+void pc802_show_tx_info(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+void pc802_show_rx_info(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+void pc802_show_tx_data(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+void pc802_show_rx_data(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+
+int pc802_download_boot_image(uint16_t port_id);
+int pc802_check_dma_timeout(uint16_t port);
+int pc802_set_ul_dma_count(uint16_t port, uint32_t n);
+uint32_t pc802_vec_read(uint32_t file_id, uint32_t offset, uint32_t address, uint32_t length);
+uint32_t pc802_vec_dump(uint32_t file_id, uint32_t address, uint32_t length);
+
+#endif /* _PC802_ETHDEV_H_ */
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pc802_logs.c npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_logs.c
--- dpdk-21.08/drivers/net/pc802/pc802_logs.c	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_logs.c	2021-12-06 14:13:02.125271012 +0800
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2020 Picocom Corporation
+ */
+
+#include "pc802_logs.h"
+
+/* declared as extern in pc802_logs.h */
+int pc802_logtype_init;
+int pc802_logtype_driver;
+
+/* only initialize log one time */
+static int pc802_log_initialized;
+
+void
+pc802_init_log(void)
+{
+	if (!pc802_log_initialized) {
+		pc802_logtype_init = rte_log_register("pmd.net.pc802.init");
+		if (pc802_logtype_init >= 0)
+			rte_log_set_level(pc802_logtype_init, RTE_LOG_NOTICE);
+		pc802_logtype_driver = rte_log_register("pmd.net.pc802.driver");
+		if (pc802_logtype_driver >= 0)
+			rte_log_set_level(pc802_logtype_driver, RTE_LOG_NOTICE);
+		pc802_log_initialized = 1;
+	}
+}
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pc802_logs.h npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_logs.h
--- dpdk-21.08/drivers/net/pc802/pc802_logs.h	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pc802_logs.h	2021-12-06 14:13:02.125271012 +0800
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018-2020 Picocom Corporation
+ */
+
+#ifndef _PC802_LOGS_H_
+#define _PC802_LOGS_H_
+
+#include <rte_log.h>
+
+extern int pc802_logtype_init;
+#define PMD_INIT_LOG(level, fmt, args...) \
+	rte_log(RTE_LOG_ ## level, pc802_logtype_init, \
+		"%s(): " fmt "\n", __func__, ##args)
+
+#define PMD_INIT_FUNC_TRACE() PMD_INIT_LOG(DEBUG, " >>")
+
+#ifdef RTE_LIBRTE_PC802_DEBUG_RX
+#define PMD_RX_LOG(level, fmt, args...) \
+	RTE_LOG(level, PMD, "%s(): " fmt "\n", __func__, ## args)
+#else
+#define PMD_RX_LOG(level, fmt, args...) do { } while(0)
+#endif
+
+#ifdef RTE_LIBRTE_PC802_DEBUG_TX
+#define PMD_TX_LOG(level, fmt, args...) \
+	RTE_LOG(level, PMD, "%s(): " fmt "\n", __func__, ## args)
+#else
+#define PMD_TX_LOG(level, fmt, args...) do { } while(0)
+#endif
+
+#ifdef RTE_LIBRTE_PC802_DEBUG_TX_FREE
+#define PMD_TX_FREE_LOG(level, fmt, args...) \
+	RTE_LOG(level, PMD, "%s(): " fmt "\n", __func__, ## args)
+#else
+#define PMD_TX_FREE_LOG(level, fmt, args...) do { } while(0)
+#endif
+
+extern int pc802_logtype_driver;
+#define PMD_DRV_LOG_RAW(level, fmt, args...) \
+	rte_log(RTE_LOG_ ## level, pc802_logtype_driver, "%s(): " fmt, \
+		__func__, ## args)
+
+#define PMD_DRV_LOG(level, fmt, args...) \
+	PMD_DRV_LOG_RAW(level, fmt "\n", ## args)
+
+
+/* log init function shared by e1000 and igb drivers */
+void pc802_init_log(void);
+
+#endif /* _PC802_LOGS_H_ */
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pcxx_ipc.c npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pcxx_ipc.c
--- dpdk-21.08/drivers/net/pc802/pcxx_ipc.c	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pcxx_ipc.c	2021-12-06 14:13:02.125271012 +0800
@@ -0,0 +1,399 @@
+#include <stdint.h>
+
+#include <rte_debug.h>
+
+#include "pc802_ethdev.h"
+#include "pcxx_ipc.h"
+
+/*Predefined Block num*/
+#define DL_CTRL_BLOCK_NUM 4
+#define UL_CTRL_BLCOK_NUM 4
+
+#define DL_DATA_BLOCK_NUM 4
+#define UL_DATA_BLCOK_NUM 4
+
+#define DL_OAM_BLOCK_NUM 2
+#define UL_OAM_BLCOK_NUM 2
+
+#define QID_DATA    PC802_TRAFFIC_5G_EMBB_DATA
+#define QID_CTRL    PC802_TRAFFIC_5G_EMBB_CTRL
+#define QID_OAM     PC802_TRAFFIC_OAM
+
+typedef enum {
+    PCXX_CTRL,
+    PCXX_DATA,
+    PCXX_OAM,
+    PCXX_INSTANCE_NUM
+} PcxxInstanceType_e;
+
+typedef enum {
+    PCXX_TX_DIRECT,
+    PCXX_RX_DIRECT,
+    PCXX_MAX_DIRECT_NUM
+} PcxxDirect_e;
+
+static PCXX_RW_CALLBACK pccxxWriteHandle[PCXX_INSTANCE_NUM] = {}; // ul mac or phy callback
+static PCXX_RW_CALLBACK pccxxReadHandle[PCXX_INSTANCE_NUM] = {}; // dl mac or phy callback
+
+static int openCtrlState = 0;
+static int openOamState = 0;
+static int openDataState = 0;
+
+int pcxxCtrlOpen(const pcxxInfo_s* info)
+{
+    if (openCtrlState != 0) {
+        printf("open Ctrl State = %d \n", openCtrlState);
+        return -1;
+    }
+
+    if (info == NULL)
+        return -1;
+
+    pccxxReadHandle[PCXX_CTRL] = info->readHandle;
+    pccxxWriteHandle[PCXX_CTRL] = info->writeHandle;
+
+    RTE_ASSERT(0 == pc802_create_tx_queue(0, QID_CTRL, 256*1024, 256, 128));
+    RTE_ASSERT(0 == pc802_create_rx_queue(0, QID_CTRL, 256*1024, 256, 128));
+
+    openCtrlState = 1;
+    return 0;
+}
+
+void pcxxCtrlClose(void)
+{
+}
+
+int pcxxOamOpen(const pcxxInfo_s* info)
+{
+    if (openOamState != 0) {
+        printf("open Ctrl State = %d \n", openOamState);
+        return -1;
+    }
+
+    if (info == NULL)
+        return -1;
+
+    pccxxReadHandle[PCXX_OAM] = info->readHandle;
+    pccxxWriteHandle[PCXX_OAM] = info->writeHandle;
+
+    RTE_ASSERT(0 == pc802_create_tx_queue(0, QID_OAM, 256*1024, 256, 128));
+    RTE_ASSERT(0 == pc802_create_rx_queue(0, QID_OAM, 256*1024, 256, 128));
+
+    openOamState = 1;
+    return 0;
+}
+
+void pcxxOamClose(void)
+{
+}
+
+int pcxxDataOpen(const pcxxInfo_s* info)
+{
+    if (openDataState != 0) {
+        printf("open Data State = %d \n", openDataState);
+        return -1;
+    }
+
+    if (info == NULL)
+        return -1;
+
+    pccxxReadHandle[PCXX_DATA] = info->readHandle;
+    pccxxWriteHandle[PCXX_DATA] = info->writeHandle;
+
+    RTE_ASSERT(0 == pc802_create_tx_queue(0, QID_DATA, 256*1024, 256, 128));
+    RTE_ASSERT(0 == pc802_create_rx_queue(0, QID_DATA, 256*1024, 256, 128));
+
+    openDataState = 1;
+    return 0;
+}
+
+void pcxxDataClose(void)
+{
+}
+
+#define NUM_DATA_BUF    64
+#define NUM_SFN_IDX 4
+#define SFN_IDX_MASK    (NUM_SFN_IDX - 1)
+
+static uint32_t sfn_idx;
+
+static char     *ctrl_buf;
+static uint32_t ctrl_length;
+
+static char     *data_buf[NUM_SFN_IDX][NUM_DATA_BUF];
+static int      data_num[NUM_SFN_IDX];
+static uint32_t data_offset;
+static uint32_t data_length;
+
+static char     *rx_ctrl_buf;
+static char     *rx_data_buf;
+
+static char     *oam_buf;
+static uint32_t oam_length;
+static char     *rx_oam_buf;
+
+int pcxxSendStart(void)
+{
+    PC802_Mem_Block_t *mblk;
+    int k;
+    ctrl_length = 0;
+    ctrl_buf = NULL;
+    for (k = 0; k < data_num[sfn_idx]; k++) {
+        mblk = (PC802_Mem_Block_t *)((char *)data_buf[sfn_idx][k] - sizeof(PC802_Mem_Block_t));
+        pc802_free_mem_block(mblk);
+        data_buf[sfn_idx][k] = NULL;
+    }
+    data_num[sfn_idx] = 0;
+    data_offset = 0;
+    data_length = 0;
+    oam_length = 0;
+    oam_buf = NULL;
+    return 0;
+}
+
+int pcxxSendEnd(void)
+{
+    PC802_Mem_Block_t *mblk_ctrl;
+    PC802_Mem_Block_t *mblk_data;
+    PC802_Mem_Block_t *mblk_oam;
+    if (data_num[sfn_idx]) {
+        mblk_data = (PC802_Mem_Block_t *)(data_buf[sfn_idx][data_num[sfn_idx] - 1] - sizeof(PC802_Mem_Block_t));
+        mblk_data->pkt_length = data_length;
+        mblk_data->pkt_type = 0;
+        mblk_data->eop = 1;
+        pc802_tx_mblk_burst(0, QID_DATA, &mblk_data, 1);
+    }
+    if (NULL != ctrl_buf) {
+        mblk_ctrl = (PC802_Mem_Block_t *)(ctrl_buf - sizeof(PC802_Mem_Block_t));
+        mblk_ctrl->pkt_length = ctrl_length;
+        mblk_ctrl->pkt_type = 1 + (0 == data_offset);
+        mblk_ctrl->eop = 1;
+        pc802_tx_mblk_burst(0, QID_CTRL, &mblk_ctrl, 1);
+        sfn_idx = (sfn_idx + 1) & SFN_IDX_MASK;
+    }
+    if (NULL != oam_buf) {
+        mblk_oam = (PC802_Mem_Block_t *)(oam_buf - sizeof(PC802_Mem_Block_t));
+        mblk_oam->pkt_length = oam_length;
+        mblk_oam->pkt_type = 2;
+        mblk_oam->eop = 1;
+        pc802_tx_mblk_burst(0, QID_OAM, &mblk_oam, 1);
+    }
+    return 0;
+}
+
+int pcxxCtrlAlloc(char** buf, uint32_t* availableSize)
+{
+    PC802_Mem_Block_t *mblk;
+    if (NULL == ctrl_buf) {
+        mblk = pc802_alloc_tx_mem_block(0, QID_CTRL);
+        if (NULL == mblk)
+            return -1;
+        ctrl_buf = (char *)&mblk[1];
+    }
+    if (NULL == ctrl_buf)
+        return -1;
+    *buf = ctrl_buf + ctrl_length;
+    *availableSize = 256 * 1024 - sizeof(PC802_Mem_Block_t) - ctrl_length;
+    return 0;
+}
+
+int pcxxCtrlSend(const char* buf, uint32_t bufLen)
+{
+    uint32_t ret;
+    RTE_ASSERT(0 == (bufLen & 3));
+    if (NULL == pccxxWriteHandle[PCXX_CTRL]) {
+        ctrl_length += bufLen;
+        return 0;
+    }
+    ret = pccxxWriteHandle[PCXX_CTRL](buf, bufLen);
+    if (ret)
+        return -1;
+    ctrl_length += bufLen;
+    return 0;
+}
+
+int pcxxCtrlRecv(void)
+{
+    PC802_Mem_Block_t *mblk_ctrl;
+    PC802_Mem_Block_t *mblk_data;
+    uint16_t num_rx;
+    uint32_t rLen = 0;
+    uint32_t offset;
+    int ret;
+
+    if (NULL == rx_ctrl_buf) {
+        num_rx = pc802_rx_mblk_burst(0, QID_CTRL, &mblk_ctrl, 1);
+        if (num_rx)
+            rx_ctrl_buf = (char *)&mblk_ctrl[1];
+    }
+    if (NULL == rx_ctrl_buf)
+        return -1;
+    mblk_ctrl = (PC802_Mem_Block_t *)(rx_ctrl_buf - sizeof(PC802_Mem_Block_t));
+    if (1 == mblk_ctrl->pkt_type) {
+        num_rx = pc802_rx_mblk_burst(0, QID_DATA, &mblk_data, 1);
+        if (0 == num_rx)
+            return -1;
+        rx_data_buf = (char *)&mblk_data[1];
+    }
+
+    if (rx_data_buf) {
+        mblk_data = (PC802_Mem_Block_t *)(rx_data_buf - sizeof(PC802_Mem_Block_t));
+        if (NULL != pccxxReadHandle[PCXX_DATA]) {
+            pccxxReadHandle[PCXX_DATA](rx_data_buf, mblk_data->pkt_length);
+        }
+    }
+    uint32_t _len = mblk_ctrl->pkt_length;
+    offset = 0;
+    while (_len > 0) {
+        if (NULL == pccxxReadHandle[PCXX_CTRL])
+            break;
+        ret = pccxxReadHandle[PCXX_CTRL](rx_ctrl_buf + offset, _len);
+        if (ret < 0)
+            break;
+        rLen = ret;
+        RTE_ASSERT(0 == (rLen & 3));
+        _len -= rLen;
+        offset += rLen;
+    }
+
+    RTE_ASSERT(0 == _len);
+
+    pc802_free_mem_block(mblk_ctrl);
+    rx_ctrl_buf = NULL;
+    if (rx_data_buf) {
+        pc802_free_mem_block(mblk_data);
+        rx_data_buf = NULL;
+    }
+
+    return 0;
+}
+
+int pcxxOamAlloc(char** buf, uint32_t* availableSize)
+{
+    PC802_Mem_Block_t *mblk;
+    if (NULL == oam_buf) {
+        mblk = pc802_alloc_tx_mem_block(0, QID_OAM);
+        if (NULL == mblk)
+            return -1;
+        oam_buf = (char *)&mblk[1];
+    }
+    if (NULL == oam_buf)
+        return -1;
+    *buf = oam_buf + oam_length;
+    *availableSize = 256 * 1024 - sizeof(PC802_Mem_Block_t) - oam_length;
+    return 0;
+}
+
+int pcxxOamSend(const char* buf, uint32_t bufLen)
+{
+    uint32_t ret;
+    RTE_ASSERT(0 == (bufLen & 3));
+    if (NULL == pccxxWriteHandle[PCXX_OAM]) {
+        oam_length += bufLen;
+        return 0;
+    }
+    ret = pccxxWriteHandle[PCXX_OAM](buf, bufLen);
+    if (ret)
+        return -1;
+    oam_length += bufLen;
+    return 0;
+}
+
+int pcxxOamRecv(void)
+{
+    PC802_Mem_Block_t *mblk_oam;
+    uint16_t num_rx;
+    uint32_t rLen = 0;
+    uint32_t offset;
+    int ret;
+
+    if (NULL == rx_oam_buf) {
+        num_rx = pc802_rx_mblk_burst(0, QID_OAM, &mblk_oam, 1);
+        if (num_rx)
+            rx_oam_buf = (char *)&mblk_oam[1];
+    }
+    if (NULL == rx_oam_buf)
+        return -1;
+    mblk_oam = (PC802_Mem_Block_t *)(rx_oam_buf - sizeof(PC802_Mem_Block_t));
+    uint32_t _len = mblk_oam->pkt_length;
+    offset = 0;
+    while (_len > 0) {
+        if (NULL == pccxxReadHandle[PCXX_OAM])
+            break;
+        ret = pccxxReadHandle[PCXX_OAM](rx_oam_buf + offset, _len);
+        if (ret < 0)
+            break;
+        rLen = ret;
+        RTE_ASSERT(0 == (rLen & 3));
+        _len -= rLen;
+        offset += rLen;
+    }
+
+    RTE_ASSERT(0 == _len);
+
+    pc802_free_mem_block(mblk_oam);
+    rx_oam_buf = NULL;
+
+    return 0;
+}
+
+int pcxxDataAlloc(uint32_t bufSize, char** buf, uint32_t* offset)
+{
+    PC802_Mem_Block_t *mblk;
+    if ((sizeof(PC802_Mem_Block_t) + data_offset + bufSize) > 256 * 1024)
+        return -1;
+    mblk = pc802_alloc_tx_mem_block(0, QID_DATA);
+    if (NULL == mblk)
+        return -1;
+    *buf = data_buf[sfn_idx][data_num[sfn_idx]] = (char *)&mblk[1];
+    *offset = data_offset;
+    return 0;
+}
+
+int pcxxDataSend(uint32_t offset, uint32_t bufLen)
+{
+    PC802_Mem_Block_t *mblk;
+    bufLen = ((bufLen + 3) >> 2) << 2;
+    if ((sizeof(PC802_Mem_Block_t) + offset + bufLen ) > 256 * 1024)
+        return -1;
+    if (pccxxWriteHandle[PCXX_DATA]) {
+        if (pccxxWriteHandle[PCXX_DATA](data_buf[sfn_idx][data_num[sfn_idx]], bufLen))
+            return -2;
+    }
+    if (data_num[sfn_idx]){
+        mblk = (PC802_Mem_Block_t *)(data_buf[sfn_idx][data_num[sfn_idx] - 1] - sizeof(PC802_Mem_Block_t));
+        mblk->pkt_length = data_length;
+        mblk->pkt_type = 0;
+        mblk->eop = 0;
+        pc802_tx_mblk_burst(0, QID_DATA, &mblk, 1);
+    }
+    data_offset += bufLen;
+    data_length = bufLen;
+    data_num[sfn_idx]++;
+    return 0;
+}
+
+void* pcxxDataRecv(uint32_t offset, uint32_t len)
+{
+    if (NULL == rx_data_buf)
+        return NULL;
+    if ((sizeof(PC802_Mem_Block_t) + offset + len)  > 256 * 1024)
+        return NULL;
+    return (void *)(rx_data_buf + offset);
+}
+
+int pcxxCtrlDestroy(void)
+{
+    return 0;
+}
+
+int pcxxOamDestroy(void)
+{
+    return 0;
+}
+
+int pcxxDataDestroy(void)
+{
+    return 0;
+}
+
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/pcxx_ipc.h npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pcxx_ipc.h
--- dpdk-21.08/drivers/net/pc802/pcxx_ipc.h	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/pcxx_ipc.h	2022-01-21 11:52:16.355570204 +0800
@@ -0,0 +1,162 @@
+#ifndef __PC802_ATL_H__
+#define __PC802_ATL_H__
+
+#include <stdint.h>
+
+typedef uint32_t (*PCXX_RW_CALLBACK)(const char* buf, uint32_t payloadSize);
+
+typedef struct {
+    PCXX_RW_CALLBACK readHandle;
+    PCXX_RW_CALLBACK writeHandle;
+} pcxxInfo_s;
+
+/**
+* @brief Create control  queues for Tx and Rx
+*
+* @param[in] info Register Tx and Rx callback functions
+* @return returns 0 if open success, or else return error
+*/
+int pcxxCtrlOpen(const pcxxInfo_s* info);
+
+/**
+* @brief Close and free the control Shared memory.
+*
+* @param	none 
+* @return	none
+*/
+void pcxxCtrlClose(void);
+
+/**
+* @brief Create OAM queues for Tx and Rx
+*
+* @param[in] info Register Tx and Rx callback functions
+* @return returns 0 if open success, or else return error
+*/
+int pcxxOamOpen(const pcxxInfo_s* info);
+
+/**
+* @brief Close and free the OAM Shared memory.
+*
+* @param	none 
+* @return	none
+*/
+void pcxxOamClose(void);
+
+/**
+* @brief Create data queues  for Rx and Tx
+*
+* @param[in] info Register Tx and Rx callback functions
+* @return returns 0 if open success, or else return error 
+*/
+int pcxxDataOpen(const pcxxInfo_s* info);
+
+/**
+* @brief Close and free the data queue.
+*
+* @param	 none
+* @return  none
+*/
+void pcxxDataClose(void);
+
+/**
+* @brief Called before sending a messages list, mainly is used to select the block .
+*
+* @param none
+* @return returns 0 if open success, or else return error
+*/
+int pcxxSendStart(void);
+
+/**
+* @brief Notify Rx side that new messages are arrived.
+*
+* @param 	none
+* @return  returns 0 if open success, or else return error
+*/
+int pcxxSendEnd(void);
+
+/**
+* @brief Allocated one control message memory from current block in used.
+*
+* @param[out] buf the allocated memory address
+* @param[out] availableSize the current available size in this block
+* @return returns 0 if open success, or else return error
+*/
+int pcxxCtrlAlloc(char** buf, uint32_t* availableSize);
+
+/**
+* @brief Update block header when the content of one control message is completed.
+*
+* @param[in] buf   write memory data
+* @param[in] bufLen length of data written  
+* @return returns 0 if open success, or else return error
+*/
+int pcxxCtrlSend(const char* buf, uint32_t bufLen);
+
+/**
+* @brief Checks the number of received control messages. Application thread may poll at function till it detects there is message from Tx side.
+*
+* @param	none
+* @return	returns 0 if handle the received messages success, or else return error  
+*/
+int pcxxCtrlRecv(void);
+
+/**
+* @brief Allocated one OAM message memory from current block in used.
+*
+* @param[out] buf the allocated memory address
+* @param[out] availableSize the current available size in this block
+* @return returns 0 if open success, or else return error
+*/
+int pcxxOamAlloc(char** buf, uint32_t* availableSize);
+
+/**
+* @brief Update block header when the content of one OAM message is completed.
+*
+* @param[in] buf   write memory data
+* @param[in] bufLen length of data written  
+* @return returns 0 if open success, or else return error
+*/
+int pcxxOamSend(const char* buf, uint32_t bufLen);
+
+/**
+* @brief Checks the number of received OAM messages. Application thread may poll at function till it detects there is message from Tx side.
+*
+* @param	none
+* @return	returns 0 if handle the received messages success, or else return error  
+*/
+int pcxxOamRecv(void);
+
+/**
+* @brief Allocated one data message memory from current block in used.
+*
+* @param[in] bufSize the alloc memory size
+* @param[out] buf the available memory address
+* @param[out] offset the data memory offset from first address
+* @return returns 0 if alloc success, or else return error 
+*/
+int pcxxDataAlloc(uint32_t bufSize, char** buf, uint32_t* offset);
+
+/**
+* @brief Update data queue context when the content of one data message is completed.
+*
+* @param[in] offset the offset value from first address of data queue
+* @param[in] bufLen the write data length
+* @return returns 0 if send success, or else return error 
+*/
+int pcxxDataSend(uint32_t offset, uint32_t bufLen);
+
+/**
+* @brief Recv data  from queue by offset
+*
+* @param[in] offset offset of read data queue, data memory offset from first address
+* @param[in] len read data queue length
+* @return return pointer to the data if success, else return NULL
+*/
+void* pcxxDataRecv(uint32_t offset, uint32_t len);
+
+int pcxxCtrlDestroy(void);
+int pcxxOamDestroy(void);
+int pcxxDataDestroy(void);
+
+#endif
+
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/rte_pmd_pc802.h npu_driver/pcie/user_space/DPDK/drivers/net/pc802/rte_pmd_pc802.h
--- dpdk-21.08/drivers/net/pc802/rte_pmd_pc802.h	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/rte_pmd_pc802.h	2022-01-21 11:52:16.355570204 +0800
@@ -0,0 +1,67 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2018-2020 Picocom Corporation
+ */
+#ifndef __RTE_PMD_PC802_H__
+#define __RTE_PMD_PC802_H__
+
+#include <stdint.h>
+#include <stdio.h>
+
+#define  DBLOG(format, ...) \
+    printf("%s : %u : " format, __func__, __LINE__, ##__VA_ARGS__)
+
+#define DIR_PCIE_DMA_DOWNLINK   1
+#define DIR_PCIE_DMA_UPLINK     0
+
+typedef enum PC802_Traffic_Type_e {
+    PC802_TRAFFIC_ETHERNET,
+    PC802_TRAFFIC_5G_EMBB_DATA,
+    PC802_TRAFFIC_5G_EMBB_CTRL,
+    PC802_TRAFFIC_5G_URLLC,
+    PC802_TRAFFIC_4G_LTE_DATA,
+    PC802_TRAFFIC_4G_LTE_CTRL,
+    PC802_TRAFFIC_OAM,
+    PC802_TRAFFIC_NUM
+} PC802_Traffic_Type_e;
+
+#define NPU_CACHE_LINE_SZ   64
+
+struct pc802_mem_block {
+    struct pc802_mem_block *next;
+    struct pc802_mem_block **first;
+    uint32_t alloced;
+    uint64_t buf_phy_addr;
+    uint32_t pkt_length;
+    uint8_t  pkt_type;
+    uint8_t  eop;
+} __attribute__((__aligned__(NPU_CACHE_LINE_SZ)));
+typedef struct pc802_mem_block PC802_Mem_Block_t;
+
+int pc802_get_socket_id(uint16_t port_id);
+
+char * picocom_pc802_version(void);
+
+int pc802_create_rx_queue(uint16_t port_id, uint16_t queue_id, uint32_t block_size, uint32_t block_num, uint16_t nb_desc);
+int pc802_create_tx_queue(uint16_t port_id, uint16_t queue_id, uint32_t block_size, uint32_t block_num, uint16_t nb_desc);
+
+PC802_Mem_Block_t * pc802_alloc_tx_mem_block(uint16_t port_id, uint16_t queue_id);
+void pc802_free_mem_block(PC802_Mem_Block_t *mblk);
+
+uint16_t pc802_rx_mblk_burst(uint16_t port_id, uint16_t queue_id,
+    PC802_Mem_Block_t **rx_blks, uint16_t nb_blks);
+uint16_t pc802_tx_mblk_burst(uint16_t port_id, uint16_t queue_id,
+    PC802_Mem_Block_t **tx_blks, uint16_t nb_blks);
+
+uint64_t *pc802_get_debug_mem(uint16_t port_id);
+void pc802_access_ep_mem(uint16_t port_id, uint32_t startAddr, uint32_t bytesNum, uint32_t cmd);
+void pc802_show_pcie_counter(uint16_t port_id);
+void pc802_show_tx_info(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+void pc802_show_rx_info(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+void pc802_show_tx_data(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+void pc802_show_rx_data(uint16_t port_id, uint16_t queue_id, uint32_t rc_counter);
+int pc802_check_dma_timeout(uint16_t port);
+int pc802_set_ul_dma_count(uint16_t port, uint32_t n);
+uint32_t pc802_vec_read(uint32_t file_id, uint32_t offset, uint32_t address, uint32_t length);
+uint32_t pc802_vec_dump(uint32_t file_id, uint32_t address, uint32_t length);
+
+#endif /* __RTE_PMD_PC802_H__ */
diff -ruN -x '*.data' dpdk-21.08/drivers/net/pc802/version.map npu_driver/pcie/user_space/DPDK/drivers/net/pc802/version.map
--- dpdk-21.08/drivers/net/pc802/version.map	1970-01-01 08:00:00.000000000 +0800
+++ npu_driver/pcie/user_space/DPDK/drivers/net/pc802/version.map	2022-01-21 11:52:16.355570204 +0800
@@ -0,0 +1,3 @@
+DPDK_21 {
+	local: *;
+};
